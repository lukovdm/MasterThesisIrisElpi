shorten coq.ltac.{ open, thenl, all }.

pred pm-reduce i:term, o:term.
pm-reduce T O :-
  Consts = [
    % base
    {{ @base.negb }}, {{ @base.beq }}, {{ @base.Pos_succ }}, {{ @base.ascii_beq }}, {{ @base.string_beq }}, {{ @base.positive_beq }}, {{ @base.ident_beq }},
    % environments
    {{ @env_lookup }}, {{ @env_lookup_delete }}, {{ @env_delete }}, {{ @env_app }}, {{ @env_replace }}, {{ @env_dom }}, {{ @env_intuitionistic }}, 
    {{ @env_spatial }}, {{ @env_counter }}, {{ @env_spatial_is_nil }}, {{ @envs_dom }}, {{ @envs_lookup }}, {{ @envs_lookup_delete }}, 
    {{ @envs_delete }}, {{ @envs_snoc }}, {{ @envs_app }}, {{ @envs_simple_replace }}, {{ @envs_replace }}, {{ @envs_split }}, 
    {{ @envs_clear_spatial }}, {{ @envs_clear_intuitionistic }}, {{ @envs_incr_counter }}, {{ @envs_split_go }}, 
    {{ @envs_split }}, {{ @env_to_prop_go }}, {{ @env_to_prop }}, {{ @env_to_prop_and_go }}, {{ @env_to_prop_and }},
    % PM list and option functions
    {{ @pm_app }}, {{ @pm_option_bind }}, {{ @pm_from_option }}, {{ @pm_option_fun }}
  ],
  std.map Consts (x\r\ sigma TMP\ x = global (const TMP), r = coq.redflags.const TMP) Deltas,
  coq.redflags.add coq.redflags.betaiotazeta Deltas RF,
  @redflags! RF => coq.reduction.cbv.norm T O.

pred unfold-id i:string, i:term, o:term.
unfold-id S I O :- 
  coq.locate S (const IP),
  unfold-gref (const IP) I O.

pred unfold-gref i:gref, i:term, o:term.
unfold-gref (const IP) I O :-
  coq.env.const IP (some Bo) _,
  ((copy (global (const IP)) Bo :- !) => copy I I'),
  coq.reduction.lazy.bi-norm I' O.

pred do-steps i:ihole.
do-steps (ihole _ (hole Type _) as IH) :-
  if-debug (coq.say "\n================= Goal =================" {ihole->string IH} ""),
  do-steps.conn Type R LF RF,
  do-steps.do IH R LF RF.

pred do-steps.open i:goal, o:list sealed-goal.
do-steps.open (goal _ _ Type Proof _) _ :-
  pm-reduce Type Type',
  get-ctx-count Type' N,
  do-steps (ihole N (hole Type' Proof)).

pred do-steps.conn i:term, o:term, o:term, o:term.
do-steps.conn Type R LF RF:-
  top-relation Type R, !,
  relation-on Type LF RF.

pred top-relation i:term, o:term.
top-relation {{ envs_entails _ lp:{{ app PS }} }} C :- C = app {std.take 2 PS}.

pred relation-on i:term, o:term, o:term.
relation-on {{ envs_entails _ lp:{{ app AS }} }} L R :- 
  std.take-last 2 AS [L, R].

pred do-steps.do i:ihole, i:term, i:term, i:term.
do-steps.do (ihole N (hole _ Proof)) {{ @iRespectful _ }} _ _ :- !,
  if-debug (coq.say "==>"),
  list->listterm [ {{ IPure (IGallinaAnon) }}, {{ IPure (IGallinaAnon) }}, {{ IIntuitionistic (IFresh) }} ] Args,
  coq.ltac.collect-goals Proof [G] _,
  open (addN N (coq.ltac.call "_iIntros0" [ trm Args ])) G [GIntro], !,
  open do-steps.open GIntro _.
do-steps.do (ihole N (hole _ Proof)) {{ @iPointwise_relation _ }} _ _ :- !,
  if-debug (coq.say ".>"),
  list->listterm [ {{ IPure (IGallinaAnon) }} ] Args,
  coq.ltac.collect-goals Proof [G] _,
  open (addN N (coq.ltac.call "_iIntros0" [ trm Args ])) G [GIntro], !,
  open do-steps.open GIntro _.
do-steps.do (ihole N H) {{ @iPersistent_relation _ }} _ _ :- !,
  if-debug (coq.say "â–¡>"),
  do-iModIntro H ModH, !,
  do-steps (ihole N ModH).
do-steps.do (ihole _ (hole _ Proof)) _ F F :-
  if-debug (coq.say "Applying assumption" {coq.term->string F}),
  list->listterm [ {{ IFresh }}, {{ IDone }} ] Args,
  coq.ltac.collect-goals Proof [G] _,
  open (coq.ltac.call "_iIntros0" [ trm Args ]) G []. %Should have an addN but crashes for some reason
do-steps.do (ihole _ (hole _ Proof)) _ F F :-
  if-debug (coq.say "Applying assumption" {coq.term->string F}),
  list->listterm [ {{ IDone }} ] Args,
  coq.ltac.collect-goals Proof [G] _,
  open (coq.ltac.call "_iIntros0" [ trm Args ]) G []. %Should have an addN but crashes for some reason
do-steps.do IH R (app [F | FS]) _ :- 
  std.exists { std.iota {calc ({std.length FS} + 1) } } (n\ std.take n FS FS'),
  if-debug (coq.say "Apply relation" {coq.term->string R} "with" {coq.term->string (app [F | FS'])}),
  do-iApplyProper IH R (app [F | FS']) HS, !,
  std.map HS (x\r\ do-steps x) _.
do-steps.do (ihole N (hole Type Proof)) _ (app [global (const F) | _ ]) _ :-
  if-debug (coq.say "Unfolding" F),
  unfold-gref (const F) Type UnfoldedType, !,
  do-steps (ihole N (hole UnfoldedType Proof)).
do-steps.do (ihole N (hole Type Proof)) _ (global (const F)) _ :-
  if-debug (coq.say "Unfolding" F),
  unfold-gref (const F) Type UnfoldedType, !,
  do-steps (ihole N (hole UnfoldedType Proof)).
do-steps.do (ihole _ (hole _ Proof)) _ _ _ :-
  if-debug (coq.say "Applying done"),
  list->listterm [ {{ IDone }} ] Args,
  coq.ltac.collect-goals Proof [G] _,
  open (coq.ltac.call "_iIntros0" [ trm Args ]) G []. %Should have an addN but crashes for some reason
do-steps.do _ T F _ :- !,
  if-debug (coq.say "No case for relation" {coq.term->string T} "with " {coq.term->string F} "ðŸ˜¢ stopping").

pred do-solve-proper i:hole.
do-solve-proper (hole Type Proof) :-
  unfold-id "IProper" Type UnfoldedType',
  coq.typecheck Proof UnfoldedType' ok,
  do-iStartProof (hole UnfoldedType' Proof) IH,
  do-steps IH.
