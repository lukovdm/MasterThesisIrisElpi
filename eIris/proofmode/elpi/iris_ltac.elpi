shorten coq.ltac.{ open, thenl, all }.

type tc_solve open-tactic.
tc_solve G GL :- coq.ltac.call "tc_solve" [] G GL.

type pm_reduce open-tactic.
pm_reduce G GL :- coq.ltac.call "pm_reduce" [] G GL.

type pm_reflexivity open-tactic.
pm_reflexivity G GL :- coq.ltac.call "pm_reflexivity" [] G GL.

type simpl open-tactic.
simpl G GL :- coq.ltac.call "simpl" [] G GL.

type split open-tactic.
split G GL :- coq.ltac.call "split" [] G GL.

type done open-tactic.
done G GL :- coq.ltac.call "done" [] G GL.

pred refine.warn i:term, i:goal, o:list sealed-goal.
refine.warn T (goal _ RawEv Ty Ev _) GS :-
  rm-evar RawEv Ev,
  @keepunivs! => coq.elaborate-skeleton T Ty TR D,
  D = ok,
  coq.ltac.collect-goals TR GS _,
  RawEv = T,
  Ev = TR.

pred thenl! i:list tactic, i:sealed-goal, o:list sealed-goal.
thenl! [] G [G].
thenl! [T|Ts] G GS :- T G NG, !, all (thenl Ts) NG GS.

type false-error string -> open-tactic.
false-error S (goal _ _ {{ False }} _ _) _ :- !, coq.ltac.fail 0 S.
false-error _ G [seal G].
