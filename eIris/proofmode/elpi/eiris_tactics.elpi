shorten coq.ltac.{ open, thenl, all }.

pred ident->term i:ident, o:string, o:term.
ident->term (iNamed S) S T :- !,
  string->stringterm S ST,
  T = {{ INamed lp:ST }}.
ident->term (iAnon N) "anon" T :- !,
  T = {{ IAnon lp:N }}.

type ident_for_pat intro_pat -> ident -> tactic.
ident_for_pat (iIdent ID) ID G [G].
ident_for_pat _ (iAnon NT) G GL :-
  open (go_iFresh NT) G GL.

type ident_for_pat.default intro_pat -> ident -> ident -> tactic.
ident_for_pat.default (iIdent ID) _ ID G [G].
ident_for_pat.default _ (iAnon NT) (iAnon NT) _G _GL.
ident_for_pat.default _ _ (iAnon NT) G GL :-
  open (go_iFresh NT) G GL.

pred do-iStartProof i:hole, o:ihole.
do-iStartProof (hole {{ let _ := _ in _ }} _) _ :- !,
  coq.error "iStartProof: goal is a `let`, use `simpl`, `intros x`, `iIntros (x)`, or `iIntros ""%x""".
do-iStartProof (hole Type Proof) (ihole N (hole NType NProof)) :- 
  coq.elaborate-skeleton {{ as_emp_valid_2 lp:Type _ (tac_start _ _) }} Type Proof ok,
  Proof = {{ as_emp_valid_2 _ _ (tac_start _ lp:NProof) }},
  coq.typecheck NProof NType ok,
  NType = {{ envs_entails (Envs _ _ lp:N) _}}.

pred do-iModIntro i:hole, o:hole.
do-iModIntro (hole Type Proof) (hole ModType ModProof) :-
  @no-tc! => coq.elaborate-skeleton {{ tac_modal_intro _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_modal_intro _ _ _ _ _ _ _ _ _ _ _ lp:TC1 lp:TC2 lp:TC3 lp:PM4 lp:SC5 lp:ModProof }},
  coq.ltac.collect-goals TC1 [G1] _,
  open tc_solve G1 [],
  coq.ltac.collect-goals TC2 [G2] _,
  open tc_solve G2 [],
  coq.ltac.collect-goals TC3 [G3] _,
  open tc_solve G3 [],
  coq.ltac.collect-goals PM4 [G4] _,
  open pm_reduce G4 [G4'],
  open tc_solve G4' [],
  coq.ltac.collect-goals SC5 [G5] _,
  open (coq.ltac.call "iSolveSideCondition" []) G5 [],
  coq.typecheck ModProof ModType ok.

pred do-iPoseProper i:ihole, i:term, i:term, o:ident, o:ihole.
do-iPoseProper (ihole N (hole Type Proof)) R F (iAnon N) (ihole NS (hole PosedType PosedProof)) :-
  increase-ctx-count N NS,
  ident->term (iAnon N) _ NT,
  @no-tc! => coq.elaborate-skeleton 
                {{ tac_pose_proof _ lp:NT _ _ (into_emp_valid_proj _ _ _ (iproper_top_to_iproper _ _ _ _ _ (_ : IProperTop lp:R lp:F _))) _}} 
                Type Proof ok,
  Proof = {{ tac_pose_proof _ _ _ _ (into_emp_valid_proj _ _ lp:IEVProof (iproper_top_to_iproper _ _ _ _ _ (lp:IPTProof : IProperTop _ _ _))) lp:PosedProof }},
  coq.ltac.collect-goals IEVProof [G1] _,
  open (coq.ltac.call "iIntoEmpValid" []) G1 TCGL,
  all (open tc_solve) TCGL [],
  coq.ltac.collect-goals IPTProof [G2] _,
  open tc_solve G2 [],
  coq.typecheck PosedProof NormType ok,
  pm-reduce NormType PosedType.

pred do-iSpecializeWand i:ihole, i:ident, o:ihole, o:ihole.
do-iSpecializeWand (ihole N (hole Type Proof)) ID 
  (ihole N (hole LType LProof)) (ihole N (hole RType RProof)) :-
    ident->term ID _IDS IDT,
    @no-tc! => coq.elaborate-skeleton {{ tac_specialize_assert_no_am _ lp:IDT _ false [] _ _ _ _ _ _ _ _ _}} 
                Type Proof ok,
    Proof = {{ tac_specialize_assert_no_am _ _ _ _ _ _ _ _ _ _ lp:RefP lp:TC1P lp:TC2P lp:ConjP}},
    coq.ltac.collect-goals RefP [G1] _,
    open pm_reflexivity G1 [],
    coq.ltac.collect-goals TC1P [G2] _,
    open tc_solve G2 [],
    coq.ltac.collect-goals TC2P [G3] _,
    open tc_solve G3 [],
    coq.typecheck ConjP RedType ok,
    pm-reduce RedType ConjType,
    coq.elaborate-skeleton {{ conj _ _ }} ConjType ConjP ok,
    ConjP = {{ conj lp:LProof lp:RProof }},
    coq.typecheck LProof LType' ok,
    pm-reduce LType' LType,
    coq.typecheck RProof RType' ok,
    pm-reduce RType' RType.

pred do-iApplySimpleHyp i:ihole, i:ident, o:ihole.
do-iApplySimpleHyp (ihole N (hole Type Proof)) ID (ihole N (hole ApType ApProof)) :-
  ident->term ID _IDS IDT,
  @no-tc! => coq.elaborate-skeleton {{ tac_apply _ lp:IDT _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_apply _ _ _ _ _ _ lp:RefProof lp:TCProof lp:ApProof }},
  coq.ltac.collect-goals RefProof [G1] _,
  open pm_reflexivity G1 [],
  coq.ltac.collect-goals TCProof [G2] _,
  open tc_solve G2 [],
  coq.typecheck ApProof RedType ok,
  pm-reduce RedType ApType.

pred do-iApplyProper i:ihole, i:term, i:term, o:list ihole.
do-iApplyProper IH R F IHS :-
  if-debug (coq.say "do-iApplyProper"),
  do-iPoseProper IH R F ID IHPosed,
  if-debug (coq.say "Posed Lemma" {ihole->string IHPosed}),
  do-iApplyProper.aux IHPosed ID IHS.
do-iApplyProper.aux IH ID [IH'] :- 
  if-debug (coq.say "simpleApplyHyp"),
  do-iApplySimpleHyp IH ID IH'.
do-iApplyProper.aux IH ID [IHL | IHS] :-
  if-debug (coq.say "specialize"),
  do-iSpecializeWand IH ID IHL IHR,
  do-iApplyProper.aux IHR ID IHS.

pred do-intro i:hole, i:term, i:string, o:hole.
do-intro (hole Type Proof) X ID (hole IntroType (IntroProof X)) :-
  std.assert! (coq.ltac.id-free? ID G) "eiIntro: name already taken",
  coq.id->name ID N,
  coq.elaborate-skeleton (fun N _ _) Type Proof ok,
  Proof = (fun _ _ IntroProof),
  coq.typecheck (IntroProof X) IntroType ok.

type go_iExFalso tactic.
go_iExFalso G GL :-
  open go_iStartProof G [G'],
  open (refine {{ @tac_ex_falso _ _ _ _ }}) G' GL.

type go_iClear ident -> tactic.
go_iClear ID G GL :-
  ident->term ID IDS IDT,
  open (refine {{ @tac_clear _ _ lp:IDT _ _ _ _ _ _ }}) G [G1, G2, G3],
  (open pm_reflexivity G1 []; coq.ltac.fail 0 "iClear:" IDS "not found"),
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G2 []; 
    coq.ltac.fail 0 "iClear:" IDS "not affine and the goal not absorbing"
  ),
  thenl [
    open pm_reduce,
    open simpl,
  ] G3 GL.

type go_iPoseLem term -> ident -> tactic.
go_iPoseLem Lem (iAnon N) G GL :-
  open go_iStartProof G [GoalStarted],
  open (go_iFresh N) GoalStarted [GoalFresh],
  ident->term (iAnon N) _ NT,
  @no-tc! => open (refine.warn {{ tac_pose_proof _ lp:NT _ _ (into_emp_valid_proj _ _ _ lp:Lem) _}}) GoalFresh [G1, G2],
  open (coq.ltac.call "iIntoEmpValid" []) G1 TCGL,
  all (open tc_solve) TCGL [],
  thenl [
    open pm_reduce,
    open (false-error "iPoseLem: not fresh"),
  ] G2 GL.

type go_iIntuitionistic ident -> tactic.
go_iIntuitionistic ID G [GRes] :-
  ident->term ID X T,
  open go_iStartProof G [G'],
  @no-tc! => open (refine {{ tac_impl_intro_intuitionistic _ lp:T _ _ _ _ _ _ _ }}) G' [GI1, GI2, GI3],
  open (tc_solve) GI1 [], 
  !,
  (open (tc_solve) GI2 []; coq.ltac.fail 0 "eiIntuitionistic: not intuitionistic"),
  open (pm_reduce) GI3 [GI4],
  open (false-error {calc ("eiIntuitionistic: " ^ X ^ " not fresh")}) GI4 [GRes].
go_iIntuitionistic ID G [GRes] :-
  ident->term ID X T,
  open go_iStartProof G [G'],
  @no-tc! => open (refine {{ tac_wand_intro_intuitionistic _ lp:T _ _ _ _ _ _ _ _ }}) G' [GW1, GW2, GW3, GW4],
  open (tc_solve) GW1 [], 
  !,
  (open (tc_solve) GW2 []; coq.ltac.fail 0 "eiIntuitionistic: not intuitionistic"),
  (open (tc_solve) GW3 []; coq.ltac.fail 0 "eiIntuitionistic: not affine and the goal not absorbing"),
  open (pm_reduce) GW4 [GW5],
  open (false-error {calc ("eiIntuitionistic: " ^ X ^ " not fresh")}) GW5 [GRes].
go_iIntuitionistic ID _ _ :- !,
  ident->term ID X _,
  coq.ltac.fail 0 {calc ("eiIntuitionistic: " ^ X ^ " could not introduce")}.

type go_iAndDestruct ident -> ident -> ident -> tactic.
go_iAndDestruct HID H1ID H2ID G GL :-
  ident->term HID ID HIDT,
  ident->term H1ID _ H1IDT,
  ident->term H2ID _ H2IDT,
  open (refine {{ @tac_and_destruct _ _ lp:HIDT _ lp:H1IDT lp:H2IDT _ _ _ _ _ _ _ }}) G [G1, G2, G3],
  (open pm_reflexivity G1 []; coq.ltac.fail 0 "iAndDestruct:" ID "not found"),
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G2 []; 
    coq.ltac.fail 0 "iAndDestruct: cannot destruct"
  ),
  thenl [
    open pm_reduce,
    open simpl,
    open (false-error "iAndDestruct: left or right not fresh")
  ] G3 GL.

type go_iOrDestruct ident -> ident -> ident -> tactic.
go_iOrDestruct HID H1ID H2ID G GL :-
  ident->term HID ID HIDT,
  ident->term H1ID _ H1IDT,
  ident->term H2ID _ H2IDT,
  open (refine {{ @tac_or_destruct _ _ lp:HIDT _ lp:H1IDT lp:H2IDT _ _ _ _ _ _ _ }}) G [G1, G2, G3],
  (open pm_reflexivity G1 []; coq.ltac.fail 0 "iOrDestruct:" ID "not found"),
  (open tc_solve G2 []; coq.ltac.fail 0 "iOrDestruct: cannot destruct"),
  thenl [
    open pm_reduce,
    open (false-error "iAndDestruct: left or right not fresh"),
    open split
  ] G3 GL.

type go_iExistDestruct ident -> option string -> ident -> tactic.
go_iExistDestruct ID X HID G GL :- !,
  ident->term ID _ IDT,
  ident->term HID _ HIDT,
  open (refine {{ @tac_exist_destruct_without_name _ _ _ lp:IDT _ lp:HIDT _ _ _ _ _ _ _ }}) G [G1, G2, G3],
  (open pm_reflexivity G1 []; coq.ltac.fail 0 "iExistDestruct:" ID "not found"),
  (open tc_solve G2 []; coq.ltac.fail 0 "iExistDestruct: cannot destruct"),
  if (X = some XN) 
    (open (go_intro XN) G3 [G4])
    (open (coq.ltac.call "intros_anon" []) G3 [G4]),
  open pm_reduce G4 [G5],
  open simpl G5 [G6],
  open (false-error "iExistDestruct: name already in use.") G6 GL.
  % Why does into Exists have a name?

type go_iExact ident -> tactic.
go_iExact ID G [] :-
  ident->term ID _ IDT,
  open (refine {{ @tac_assumption _ _ lp:IDT _ _ _ _ _ _ }}) G [G1, G2, G3],
  (open pm_reflexivity G1 []; coq.ltac.fail 0 "iExact:" ID "not found"),
  (open tc_solve G2 []; coq.ltac.fail 0 "iExact:" ID "does not match goal"),
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G3 [];
    coq.ltac.fail 0 "iExact: remaining hypotheses not affine and the goal not absorbing"
  ).

pred go_iDestruct i:ident, o:intro_pat, i:sealed-goal, o:list sealed-goal.
% go_iDestruct ID IP _ _ :- coq.say "go_iDestruct: " ID IP, fail.
go_iDestruct ID (iIdent ID) G [G].
go_iDestruct (iAnon _) iFresh G [G]. 
go_iDestruct ID iDrop G GL :-
  go_iClear ID G GL.
go_iDestruct ID (iList [[]]) G GL :-
  thenl [
    go_iExFalso,
    go_iExact ID
  ] G GL.
go_iDestruct ID (iList [[iPure PN, IP]]) G GL :- !,
  ident_for_pat.default IP ID HID G [G'],
  go_iExistDestruct ID PN HID G' [G''],
  go_iDestruct HID IP G'' GL.
  % This case now also handles the pure and case with typeclasses,
  % however, that is not neccessary as we can just backtrack in here
  % And take the next case if iExistsDestruct fails.
go_iDestruct ID (iList [[IP1, IP2]]) G GL :-
  ident_for_pat.default IP1 ID ID1 G [G'],
  ident_for_pat IP2 ID2 G' [G''],
  thenl [
    go_iAndDestruct ID ID1 ID2,
    go_iDestruct ID1 IP1,
    go_iDestruct ID2 IP2
  ] G'' GL.
go_iDestruct ID (iList [[IP1], [IP2]]) G GL :-
  ident_for_pat.default IP1 ID ID1 G [G'],
  ident_for_pat IP2 ID2 G' [G''],
  go_iOrDestruct ID ID1 ID2 G'' [G1, G2],
  go_iDestruct ID1 IP1 G1 GL1,
  go_iDestruct ID2 IP2 G2 GL2,
  std.append GL1 GL2 GL.
go_iDestruct _ IP G [G] :-
  coq.say "eiDestruct: Skipping " {std.any->string IP}.

pred do-iIntros.open i:list intro_pat, o:list ihole, i:goal, o:list sealed-goal.
do-iIntros.open IPS IHS (goal _ _ Type Proof _) _ :-
  pm-reduce Type Type',
  get-ctx-count Type' N,
  do-iIntros (ihole N (hole Type' Proof)) IPS IHS.

pred do-iIntros i:ihole, i:list intro_pat, o:list ihole.
:name "do-iIntros.start"
do-iIntros IH [] [IH].
% do-iIntros (ihole N (hole _ Proof)) [iCoqIntro X | IPS] IHS:-
%   coq.ltac.collect-goals Proof [G] _,
%   open (addN N (coq.ltac.call-ltac1 X)) G GL,
%   all (open (do-iIntros.open IPS IHS)) GL _.
do-iIntros [iSimpl | IPS] G GL :-
  open simpl G [G'],
  do-iIntros IPS G' GL.
do-iIntros [iDone | IPS] G GL :-
  (open done G [G']; G' = G),
  do-iIntros IPS G' GL.
do-iIntros (ihole N (hole Type Proof)) [iDrop | IPS] IHS :- !,
  (
    (
      coq.elaborate-skeleton {{ tac_impl_intro_drop _ _ _ _ _ _ }} Type Proof,
      Proof = {{ tac_impl_intro_drop _ _ _ _ _ lp:DropProof }},
      coq.typecheck DropProof DropType
    );
    (
      coq.elaborate-skeleton {{ tac_wand_intro_drop _ _ _ _ _ _ _ }} Type Proof,
      Proof = {{ tac_wand_intro_drop _ _ _ _ _ _ lp:DropProof }},
      coq.typecheck DropProof DropType
    );
    (!, coq.ltac.fail 0 "eiIntro: Could not introduce", fail)
  ),
  do-iIntros (ihole N (hole DropType DropProof)) IPS IHS.
do-iIntros (ihole N (hole Type Proof)) [iPure (some X) | IPS] IHS :- !,
  coq.elaborate-skeleton {{ tac_forall_intro_nameless _ _ _ _ _ _ }} Type Proof,
  Proof = {{ tac_forall_intro_nameless _ _ _ _ _ lp:NamelessProof }},
  coq.typecheck NamelessProof NamelessType ok,
  pi h\ (
    do-intro (hole NamelessType NamelessProof) h X (hole IntroType IntroProof),
    coq.reduction.lazy.bi-norm IntroType IntroType',
    do-iIntros (ihole N (hole IntroType' IntroProof)) IPS IHS
  ).
do-iIntros [iPure (none) | IPS] G GL :-
  open go_iStartProof G [StartedG],
  open (refine {{ tac_forall_intro_nameless _ _ _ _ _ _ }}) StartedG [G'],
  open (coq.ltac.call "intros_anon" []) G' [G''],
  open bi-normalize G'' [G'''],
  do-iIntros IPS G''' GL.
do-iIntros [iIdent ID | IPS] G GL :-
  ident->term ID X T,
  open go_iStartProof G [G'],
  (
    open (refine {{ @tac_impl_intro _ _ lp:T _ _ _ _ _ _ _ }}) G' [GRes];
    (
      open (refine {{ @tac_wand_intro _ _ lp:T _ _ _ _ _ }}) G' [G''], !,
      open (pm_reduce) G'' [G'''],
      open (false-error {calc ("eiIntro: " ^ X ^ " not fresh")}) G''' [GRes]
      );
    (!, coq.ltac.fail 0 {calc ("eiIntro: " ^ X ^ " could not introduce")}, fail)
  ),
  do-iIntros IPS GRes GL.
do-iIntros [iIntuitionistic iFresh | IPS] G GL :- !,
  open go_iStartProof G [StartedGoal],
  open (go_iFresh N) StartedGoal [FreshGoal],
  go_iIntuitionistic (iAnon N) FreshGoal [IntroGoal],
  do-iIntros IPS IntroGoal GL.
do-iIntros [iIntuitionistic (iIdent ID) | IPS] G GL :-
  open go_iStartProof G [G'],
  go_iIntuitionistic ID G' [GRes],
  do-iIntros IPS GRes GL.
do-iIntros [iIntuitionistic (iList IPS) | IPSS] G GL :-
  open go_iStartProof G [StartedGoal],
  open (go_iFresh N) StartedGoal [FreshGoal],
  go_iIntuitionistic (iAnon N) FreshGoal [IntroGoal],
  go_iDestruct (iAnon N) (iList IPS) IntroGoal GL',
  all (do-iIntros IPSS) GL' GL.
do-iIntros [iList IPS | IPSS] G GL :- !,
  open go_iStartProof G [StartedGoal],
  open (go_iFresh N) StartedGoal [FreshGoal],
  do-iIntros [iIdent (iAnon N)] FreshGoal [IntroGoal],
  go_iDestruct (iAnon N) (iList IPS) IntroGoal GL',
  all (do-iIntros IPSS) GL' GL.