accumulate eIris/common/stdpp.
accumulate eIris/common/parser.
accumulate eIris/common/tokenize.
accumulate eIris/proofmode/elpi/iris_ltac.
accumulate eIris/proofmode/elpi/reduction.

shorten coq.ltac.{ open, thenl, all }.


% Manage identifiers as coq terms
pred ident->term i:ident, o:string, o:term.
ident->term (iNamed S) S T :- !,
  string->stringterm S ST,
  T = {{ INamed lp:ST }}.
ident->term (iAnon N) "anon" T :- !,
  T = {{ IAnon lp:N }}.


pred ident-for-pat i:intro_pat, i:term, o:ident, o:term.
ident-for-pat (iIdent ID) N ID N.
ident-for-pat _ NT (iAnon NT) NS :-
  increase-ctx-count NT NS.


pred ident-for-pat.default i:intro_pat, i:ident, i:term, o:ident, o:term.
ident-for-pat.default (iIdent ID) _ N ID N.
ident-for-pat.default _ (iAnon NT) N (iAnon NT) N.
ident-for-pat.default _ _ NT (iAnon NT) NS :-
  increase-ctx-count NT NS.


% Start an Iris proof
pred do-iStartProof i:hole, o:ihole.
do-iStartProof (hole {{ let _ := _ in _ }} _) _ :- !,
  coq.error "iStartProof: goal is a `let`, use `simpl`, `intros x`, `iIntros (x)`, or `iIntros ""%x""".
do-iStartProof (hole {{ @envs_entails lp:PROP (@Envs lp:PROPE lp:CI lp:CS lp:N) lp:P }} Proof) (ihole N (hole {{ @envs_entails lp:PROP (@Envs lp:PROPE lp:CI lp:CS lp:N) lp:P }} Proof)) :- !.
do-iStartProof (hole Type Proof) (ihole N (hole NType NProof)) :- 
  coq.elaborate-skeleton {{ as_emp_valid_2 lp:Type _ (tac_start _ _) }} Type Proof ok,
  Proof = {{ as_emp_valid_2 _ _ (tac_start _ lp:NProof) }},
  coq.typecheck NProof NType ok,
  NType = {{ envs_entails (Envs _ _ lp:N) _}}.


% Introduce a mod
pred do-iModIntro i:hole, o:hole.
do-iModIntro (hole Type Proof) (hole ModType ModProof) :-
  @no-tc! => coq.elaborate-skeleton {{ tac_modal_intro _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_modal_intro _ _ _ _ _ _ _ _ _ _ _ lp:TC1 lp:TC2 lp:TC3 lp:PM4 lp:SC5 lp:ModProof }},
  coq.ltac.collect-goals TC1 [G1] _,
  open tc_solve G1 [],
  coq.ltac.collect-goals TC2 [G2] _,
  open tc_solve G2 [],
  coq.ltac.collect-goals TC3 [G3] _,
  open tc_solve G3 [],
  coq.ltac.collect-goals PM4 [G4] _,
  open pm_reduce G4 [G4'],
  open tc_solve G4' [],
  coq.ltac.collect-goals SC5 [G5] _,
  open (coq.ltac.call "iSolveSideCondition" []) G5 [],
  coq.typecheck ModProof ModType ok.


pred do-intros-forall i:hole, i:(hole -> prop).
do-intros-forall (hole (prod N T F) Proof) C :- !,
  if-debug (coq.say "introducing" N),
  coq.elaborate-skeleton (fun N T _) (prod N T F) Proof ok,
  Proof = (fun _ _ IntroFProof),
  @pi-decl N T x\
    do-intros-forall (hole (F x) (IntroFProof x)) C.
do-intros-forall H F :- F H.


pred do-intro i:string, i:hole, i:(hole -> prop).
do-intro ID (hole Type Proof) C :-
  coq.ltac.collect-goals Proof [G] _,
  open (g\gl\ std.assert! (coq.ltac.id-free? ID g) "eiIntro: name already taken") G _,
  coq.id->name ID N,
  coq.elaborate-skeleton (fun N _ _) Type Proof ok,
  Proof = (fun _ T IntroFProof),
  @pi-decl N T x\ 
    coq.typecheck (IntroFProof x) (F x) ok,
    C (hole (F x) (IntroFProof x)).


pred do-intro-anon i:hole, i:(hole -> prop).
do-intro-anon (hole Type Proof) C :-
  coq.ltac.fresh-id "a" {{ False }} ID,
  coq.id->name ID N,
  coq.elaborate-skeleton (fun N _ _) Type Proof ok,
  Proof = (fun _ T IntroFProof),
  @pi-decl N T x\ 
    coq.typecheck (IntroFProof x) (F x) ok,
    C (hole (F x) (IntroFProof x)).


pred do-iExFalso i:hole, o:hole.
do-iExFalso (hole Type Proof) (hole FalseType FalseProof) :-
  coq.elaborate-skeleton {{ tac_ex_falso _ _ _ }} Type Proof ok,
  Proof = {{ tac_ex_falso _ _ lp:FalseProof }},
  coq.typecheck FalseProof FalseType ok.


pred do-iClear i:ident, i:hole, o:hole.
do-iClear ID (hole Type Proof) (hole ClearType ClearProof) :-
  ident->term ID IDS IDT,

  @no-tc! => coq.elaborate-skeleton {{ tac_clear _ lp:IDT _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_clear _ _ _ _ _ lp:Lookup lp:TC lp:ClearProof }},

  coq.ltac.collect-goals Lookup [G1] _,
  (open pm_reflexivity G1 []; coq.error "iClear:" IDS "not found"),
  coq.ltac.collect-goals TC [G2] _,
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G2 []; 
    coq.error "iClear:" IDS "not affine and the goal not absorbing"
  ),

  coq.typecheck ClearProof RedType ok,
  pm-reduce RedType ClearType. 
  % I am skipping the simpl here, and hope it doesn't matter as much.


pred do-iPoseLem i:term, i:ihole, o:ident, i:list (hole -> prop), o:ihole.
do-iPoseLem Lem (ihole N (hole Type Proof)) (iAnon N) Cs (ihole NS (hole PosedType PosedProof)) :-
  increase-ctx-count N NS,
  ident->term (iAnon N) _ NT,

  @no-tc! => coq.elaborate-skeleton 
                {{ tac_pose_proof _ lp:NT _ _ (into_emp_valid_proj _ _ _ lp:Lem) _}} 
                Type Proof D,
  if (D = ok) (true) (if-debug (coq.say "pose lem error" D), fail),
  Proof = {{ tac_pose_proof _ _ _ _ (into_emp_valid_proj _ _ lp:IEVProof _) lp:PosedProof }},

  coq.ltac.collect-goals IEVProof [G1] _,
  open (coq.ltac.call "iIntoEmpValid" []) G1 GL,
  std.forall2 GL Cs (sg\ c\ open (g\gl\ sigma Proof'\ sigma Type'\ 
                                  g = (goal _ _ Type' Proof' _), !,
                                  c (hole Type' Proof')
                    ) sg _),

  coq.typecheck PosedProof NormType ok,
  pm-reduce NormType PosedType.


pred do-iPoseHyp i:term, i:ihole, o:ident, o:ihole.
do-iPoseHyp Hyp (ihole N (hole Type Proof)) (iAnon N) (ihole NS (hole PosedType PosedProof)) :-
  increase-ctx-count N NS,
  ident->term (iAnon N) _ NT,
  @no-tc! => coq.elaborate-skeleton 
                {{ tac_pose_proof_hyp _ lp:Hyp lp:NT _ _}} 
                Type Proof ok,
  Proof = {{ tac_pose_proof_hyp _ _ _ _ lp:PosedProof }},

  coq.typecheck PosedProof NormType ok,
  pm-reduce NormType PosedType,
  if (PosedType = {{ False }}) (coq.error "Could not find Hyp" {coq.term->string NormType}) (true).


pred do-iSpecializeWand i:ihole, i:ident, o:ihole, o:ihole.
do-iSpecializeWand (ihole N (hole Type Proof)) ID 
  (ihole N (hole LType LProof)) (ihole N (hole RType RProof)) :-
    ident->term ID _IDS IDT,
    @no-tc! => coq.elaborate-skeleton {{ tac_specialize_assert_no_am _ lp:IDT _ false [] _ _ _ _ _ _ _ _ _}} 
                Type Proof ok,
    Proof = {{ tac_specialize_assert_no_am _ _ _ _ _ _ _ _ _ _ lp:RefP lp:TC1P lp:TC2P lp:ConjP}},
    coq.ltac.collect-goals RefP [G1] _,
    open pm_reflexivity G1 [],
    coq.ltac.collect-goals TC1P [G2] _,
    open tc_solve G2 [],
    coq.ltac.collect-goals TC2P [G3] _,
    open tc_solve G3 [],
    coq.typecheck ConjP RedType ok,
    pm-reduce RedType ConjType,
    coq.elaborate-skeleton {{ conj _ _ }} ConjType ConjP ok,
    ConjP = {{ conj lp:LProof lp:RProof }},
    coq.typecheck LProof LType' ok,
    pm-reduce LType' LType,
    coq.typecheck RProof RType' ok,
    pm-reduce RType' RType.


pred do-iApplySimpleHyp i:ihole, i:ident, o:ihole.
do-iApplySimpleHyp (ihole N (hole Type Proof)) ID (ihole N (hole ApType ApProof)) :-
  ident->term ID _IDS IDT,
  @no-tc! => coq.elaborate-skeleton {{ tac_apply _ lp:IDT _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_apply _ _ _ _ _ _ lp:RefProof lp:TCProof lp:ApProof }},
  coq.ltac.collect-goals RefProof [G1] _,
  open pm_reflexivity G1 [],
  coq.ltac.collect-goals TCProof [G2] _,
  open tc_solve G2 [],
  coq.typecheck ApProof RedType ok,
  pm-reduce RedType ApType.


pred do-iApplySimpleExact i:ihole, i:ident.
do-iApplySimpleExact (ihole _ (hole Type Proof)) ID :-
  ident->term ID _IDS IDT,
  @no-tc! => coq.elaborate-skeleton {{ tac_assumption _ lp:IDT _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_assumption _ _ _ _ _ lp:RefProof lp:TCProof lp:RTCProof }},
  coq.ltac.collect-goals RefProof [G1] _,
  open pm_reflexivity G1 [],
  coq.ltac.collect-goals TCProof [G2] _,
  open tc_solve G2 [],
  coq.ltac.collect-goals RTCProof [G3] _,
  open (pm_reduce) G3 [G3'],
  open tc_solve G3' [].


pred do-iApplyLem i:term, i:ihole, i:list (hole -> prop), o:list ihole.
do-iApplyLem Lem IH Cs IHS :-
  if-debug (coq.say "do-iApplyLem" {coq.term->string Lem}),
  do-iPoseLem Lem IH ID Cs IHPosed, !,
  if-debug (coq.say "Posed Lemma"),
  do-iApplyLem.aux IHPosed ID IHS.
do-iApplyLem.aux IH ID [IH'] :- 
  if-debug (coq.say "simpleApplyHyp" {ihole->string IH}),
  do-iApplySimpleHyp IH ID IH'.
do-iApplyLem.aux IH ID [] :- 
  if-debug (coq.say "simpleApplyExact"),
  do-iApplySimpleExact IH ID.
do-iApplyLem.aux IH ID [IHL | IHS] :-
  if-debug (coq.say "specialize"),
  do-iSpecializeWand IH ID IHL IHR,
  if-debug (coq.say "Specialized Lemma" {ihole->string IHL} {ihole->string IHR}),
  do-iApplyLem.aux IHR ID IHS.


pred do-iApplyHyp i:string, i:ihole, o:list ihole.
do-iApplyHyp HypString IH IHS :-
  string->stringterm HypString Hyp,
  if-debug (coq.say "do-iApplyHyp" HypString ":-" {ihole->string IH}),
  do-iPoseHyp Hyp IH ID IHPosed, !,
  if-debug (coq.say "Posed Hyp"),
  do-iApplyHyp.aux IHPosed ID IHS.
do-iApplyHyp.aux IH ID [IH'] :- 
  if-debug (coq.say "simpleApplyHyp" {ihole->string IH}),
  do-iApplySimpleHyp IH ID IH'.
do-iApplyHyp.aux IH ID [] :- 
  if-debug (coq.say "simpleApplyExact"),
  do-iApplySimpleExact IH ID.
do-iApplyHyp.aux IH ID [IHL | IHS] :-
  if-debug (coq.say "specialize"),
  do-iSpecializeWand IH ID IHL IHR, !,
  if-debug (coq.say "Specialized Lemma" {ihole->string IHL} {ihole->string IHR}),
  do-iApplyHyp.aux IHR ID IHS.


pred do-iIntuitionistic i:ident, i:hole, o:hole.
do-iIntuitionistic ID (hole Type Proof) (hole IntType IntProof) :-
  ident->term ID X T,

  @no-tc! => coq.elaborate-skeleton {{ tac_impl_intro_intuitionistic _ lp:T _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_impl_intro_intuitionistic _ _ _ _ _ _ lp:FromImpl lp:IP lp:IntProof }},

  coq.ltac.collect-goals FromImpl [GI1] _,
  open (tc_solve) GI1 [], 
  !,
  coq.ltac.collect-goals IP [GI2] _,
  (open (tc_solve) GI2 []; coq.error "eiIntuitionistic: not intuitionistic"),

  coq.typecheck IntProof RedType ok,
  pm-reduce RedType IntType,
  if (IntType = {{ False }}) (coq.error "eiIntuitionistic: " X " not fresh") (true).

do-iIntuitionistic ID (hole Type Proof) (hole IntType IntProof) :-
  ident->term ID X T,

  % if-debug (coq.say "intui1" Proof),
  @no-tc! => coq.elaborate-skeleton {{ tac_wand_intro_intuitionistic _ lp:T _ _ _ _ _ _ _ _ }} Type Proof ok,
  % if-debug (coq.say "intui2" Proof),
  Proof = {{ tac_wand_intro_intuitionistic _ lp:T _ _ _ _ lp:FromWand lp:IP lp:TCOR lp:IntProof }},
  % if-debug (coq.say "intui3" IntProof),

  coq.ltac.collect-goals FromWand [GW1] _,
  open (tc_solve) GW1 [], 
  !,
  coq.ltac.collect-goals IP [GW2] _,
  (open (tc_solve) GW2 []; coq.error "eiIntuitionistic: not intuitionistic"),
  coq.ltac.collect-goals TCOR [GW3] _,
  (open (tc_solve) GW3 []; coq.error "eiIntuitionistic: not affine and the goal not absorbing"),

  coq.typecheck IntProof RedType ok,
  pm-reduce RedType IntType,
  if (IntType = {{ False }}) (coq.error "eiIntuitionistic: " X " not fresh") (true).

do-iIntuitionistic ID _ _ :- !,
  ident->term ID X _,
  coq.error {calc ("eiIntuitionistic: " ^ X ^ " could not introduce")}.


pred do-iAndDestruct i:ident, i:ident, i:ident, i:hole, o:hole.
do-iAndDestruct HID H1ID H2ID (hole Type Proof) (hole AndType AndProof) :-
  ident->term HID ID HIDT,
  ident->term H1ID _ H1IDT,
  ident->term H2ID _ H2IDT,

  @no-tc! => coq.elaborate-skeleton {{ tac_and_destruct _ lp:HIDT _ lp:H1IDT lp:H2IDT _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_and_destruct _ _ _ _ _ _ _ _ _ lp:Lookup lp:Into lp:AndProof }},

  coq.ltac.collect-goals Lookup [G1] _,
  (open pm_reflexivity G1 []; coq.error "iAndDestruct:" ID "not found"),
  coq.ltac.collect-goals Into [G2] _,
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G2 []; 
    coq.error "iAndDestruct: cannot destruct"
  ),

  coq.typecheck AndProof RedType ok,
  pm-reduce RedType AndType,
  if (AndType = {{ False }}) (coq.error "iAndDestruct: left or right not fresh") (true).


pred do-iOrDestruct i:ident, i:ident, i:ident, i:hole, o:hole, o:hole.
do-iOrDestruct HID H1ID H2ID (hole Type Proof) (hole OrLType OrLProof) (hole OrRType OrRProof) :-
  ident->term HID ID HIDT,
  ident->term H1ID _ H1IDT,
  ident->term H2ID _ H2IDT,
  
  @no-tc! => coq.elaborate-skeleton {{ tac_or_destruct _ lp:HIDT _ lp:H1IDT lp:H2IDT _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_or_destruct _ _ _ _ _ _ _ _ _ lp:Lookup lp:Into lp:ConjProof }},
  
  coq.ltac.collect-goals Lookup [G1] _,
  (open pm_reflexivity G1 []; coq.error "iOrDestruct:" ID "not found"),
  coq.ltac.collect-goals Into [G2] _,
  (open tc_solve G2 []; coq.error "iOrDestruct: cannot destruct"),
  
  coq.typecheck ConjProof RedType ok,
  pm-reduce RedType ConjType,
  if (ConjType = {{ False }}) (coq.error "iAndDestruct: left or right not fresh") (true),

  coq.elaborate-skeleton {{ conj _ _ }} ConjType ConjProof ok,
  ConjProof = {{ conj lp:OrLProof lp:OrRProof }},
  coq.typecheck OrLProof OrLType ok,
  coq.typecheck OrRProof OrRType ok.


pred do-iExistDestruct i:ident, i:option string, i:ident, i:hole, i:(hole -> prop).
do-iExistDestruct ID X HID (hole Type Proof) C :- !,
  ident->term ID _ IDT,
  ident->term HID _ HIDT,

  @no-tc! => coq.elaborate-skeleton {{ tac_exist_destruct_without_name _ lp:IDT _ lp:HIDT _ _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_exist_destruct_without_name _ _ _ _ _ _ _ _ lp:Lookup lp:Into lp:ExistProof }},

  coq.ltac.collect-goals Lookup [G1] _,
  (open pm_reflexivity G1 []; coq.error "iExistDestruct:" ID "not found"),
  coq.ltac.collect-goals Into [G2] _,
  (open tc_solve G2 []; coq.error "iExistDestruct: cannot destruct"),

  coq.typecheck ExistProof RedType ok,
  pm-reduce RedType ExistType,
  if (X = some XN) 
    (do-intro XN (hole ExistType ExistProof) C)
    (
      coq.ltac.collect-goals ExistProof [G3] _,
      open (coq.ltac.call "intros_anon" []) G3 [G4],
      open (g\gl\ sigma AnonRedType\ sigma AnonType\ sigma AnonProof\ 
                g = (goal _ _ AnonRedType AnonProof _), 
                pm-reduce AnonRedType AnonType,
                C (hole AnonType AnonProof)
           ) G4 _
    ).


pred do-iExact i:ident, i:hole.
do-iExact ID (hole Type Proof) :-
  ident->term ID IDS IDT,

  @no-tc! => coq.elaborate-skeleton {{ tac_assumption _ lp:IDT _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_assumption _ _ _ _ _ lp:Lookup lp:FromAs lp:TC }},

  coq.ltac.collect-goals Lookup [G1] _,
  (open pm_reflexivity G1 []; coq.error "iExact:" IDS "not found"),
  coq.ltac.collect-goals FromAs [G2] _,
  (open tc_solve G2 []; coq.error "iExact:" IDS "does not match goal"),
  coq.ltac.collect-goals TC [G3] _,
  (
    thenl [
      open pm_reduce,
      open tc_solve
    ] G3 [];
    coq.error "iExact: remaining hypotheses not affine and the goal not absorbing"
  ).


pred do-iDestruct i:ident, o:intro_pat, i:ihole, i:(ihole -> prop).
do-iDestruct ID IP _ _ :- if-debug (coq.say "do-iDestruct: " ID IP), fail.
do-iDestruct ID (iIdent ID) IH C :- !, C IH.
do-iDestruct (iAnon _) iFresh IH C :- !, C IH. 
do-iDestruct ID iDrop (ihole N H) C :- !, do-iClear ID H H', C (ihole N H').
do-iDestruct ID (iList [[]]) (ihole _ H) _ :-
  do-iExFalso H H',
  do-iExact ID H'.
do-iDestruct ID (iList [[iPure PN, IP]]) (ihole N H) C :- !,
  ident-for-pat.default IP ID N HID NS,
  do-iExistDestruct ID PN HID H (h\ do-iDestruct HID IP (ihole NS h) C).
  % This case now also handles the pure and case with typeclasses,
  % however, that is not neccessary as we can just backtrack in here
  % And take the next case if iExistsDestruct fails.
do-iDestruct ID (iList [[IP1, IP2]]) (ihole N H) C :-
  ident-for-pat.default IP1 ID N ID1 N',
  ident-for-pat IP2 N' ID2 N'',
  do-iAndDestruct ID ID1 ID2 H H', !,
  do-iDestruct ID1 IP1 (ihole N'' H') (ih\ do-iDestruct ID2 IP2 ih C).
do-iDestruct ID (iList [[IP1], [IP2]]) (ihole N H) C :-
  ident-for-pat.default IP1 ID N ID1 N',
  ident-for-pat IP2 N' ID2 N'',
  do-iOrDestruct ID ID1 ID2 H HL HR, !,
  do-iDestruct ID1 IP1 (ihole N'' HL) C, !,
  do-iDestruct ID2 IP2 (ihole N'' HR) C.
do-iDestruct _ IP IH C :-
  coq.say "eiDestruct: Skipping " {std.any->string IP}, !,
  C IH.

pred do-iIntros i:(list intro_pat), i:ihole, i:(ihole -> prop).
do-iIntros [IP | _] IH _ :- if-debug (coq.say "do-iIntros: " IP "in" {ihole->string IH}), fail.
do-iIntros [] IH C :- !, if-debug (coq.say "do-iIntros done"), C IH.
do-iIntros [iCoqIntro X | IPS] (ihole N (hole _ Proof)) C :-
  coq.ltac.collect-goals Proof [G] _,
  open (coq.ltac.call-ltac1 X) G [GTac], !,
  open (g\gl\ sigma TacProof\ sigma TacType\ 
          g = (goal _ _ TacType TacProof _), !,
          do-iIntros IPS (ihole N (hole TacType TacProof)) C
       ) GTac _.
do-iIntros [iSimpl | IPS] (ihole N (hole _ Proof)) C :-
  coq.ltac.collect-goals Proof [G] _,
  open simpl G [G'], !,
  open (g\gl\ sigma SimplProof\ sigma SimplType\ 
          g = (goal _ _ SimplType SimplProof _), !,
          do-iIntros IPS (ihole N (hole SimplType SimplProof)) C
       ) G' _.
do-iIntros [iDone | IPS] (ihole N (hole _ Proof)) C :-
  coq.ltac.collect-goals Proof [G] _,
  (open done G [G']; G' = G), !,
  open (g\gl\ sigma DoneProof\ sigma DoneType\ 
          g = (goal _ _ DoneType DoneProof _), !,
          do-iIntros IPS (ihole N (hole DoneType DoneProof)) C
       ) G' _.
do-iIntros [iFresh | IPS] (ihole N H) C :- !,
  increase-ctx-count N NS,
  do-iIntros [iIdent (iAnon N)] (ihole NS H) (ih\ !, do-iIntros IPS ih C).
do-iIntros [iDrop | IPS] (ihole N (hole Type Proof)) C :- !,
  (
    (coq.elaborate-skeleton {{ tac_impl_intro_drop _ _ _ _ _ _ }} Type Proof ok, Proof = {{ tac_impl_intro_drop _ _ _ _ _ lp:IntroProof }});
    (coq.elaborate-skeleton {{ tac_wand_intro_drop _ _ _ _ _ _ _ }} Type Proof ok, Proof = {{ tac_wand_intro_drop _ _ _ _ _ _ lp:IntroProof }});
    % TODO: Not sure what the forall case is.
    (!, coq.error "eiIntro: Could not introduce", fail)
  ),
  coq.typecheck IntroProof IntroType ok, !,
  do-iIntros IPS (ihole N (hole IntroType IntroProof)) C.
do-iIntros [iPure (some X) | IPS] (ihole N (hole Type Proof)) C :-
  coq.elaborate-skeleton {{ tac_forall_intro_nameless _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_forall_intro_nameless _ _ _ _ _ lp:IProof }},
  coq.typecheck IProof IType ok, !,
  do-intro X (hole IType IProof) (h\ sigma IntroProof\ sigma IntroType\ sigma NormType\
    h = hole IntroType IntroProof,
    coq.reduction.lazy.bi-norm IntroType NormType, !,
    do-iIntros IPS (ihole N (hole NormType IntroProof)) C
  ).
do-iIntros [iPure (none) | IPS] (ihole N (hole Type Proof)) C :-
  coq.elaborate-skeleton {{ tac_forall_intro_nameless _ _ _ _ _ _ }} Type Proof ok,
  Proof = {{ tac_forall_intro_nameless _ _ _ _ _ lp:IProof }},
  % coq.typecheck IProof IType ok, !,
  % do-intro-anon (hole IType IProof) (h\ sigma IntroProof\ sigma IntroType\ sigma NormType\
  %   h = hole IntroType IntroProof,
  %   coq.reduction.lazy.bi-norm IntroType NormType, !,
  %   do-iIntros IPS (ihole N (hole NormType IntroProof)) C
  % ).
  coq.ltac.collect-goals IProof [G] _,
  open (coq.ltac.call "intros_anon" []) G [G'],
  open (g\gl\ sigma AnonRedType\ sigma AnonType\ sigma AnonProof\ 
            g = (goal _ _ AnonRedType AnonProof _), 
            coq.reduction.lazy.bi-norm AnonRedType AnonType, !,
            do-iIntros IPS (ihole N (hole AnonType AnonProof)) C
        ) G' _.
do-iIntros [iIdent ID | IPS] (ihole N (hole Type Proof)) C :-
  ident->term ID X T,
  (
    (
      coq.elaborate-skeleton {{ tac_impl_intro _ lp:T _ _ _ _ _ _ _ }} Type Proof ok, 
      Proof = {{ tac_impl_intro _ _ _ _ _ _ _ _ lp:IProof }},
      coq.typecheck IProof IType ok
    );
    (
      coq.elaborate-skeleton {{ tac_wand_intro _ lp:T _ _ _ _ _ }} Type Proof ok, !,
      Proof = {{ tac_wand_intro _ _ _ _ _ _ lp:IProof }}, 
      coq.typecheck IProof IType' ok,
      pm-reduce IType' IType,
      if (IType = {{ False }}) (coq.error "eiIntro: " X " not fresh") (true)
    );
    coq.error "eiIntro: " X " could not introduce"
  ), !,
  do-iIntros IPS (ihole N (hole IType IProof)) C.
do-iIntros [iModalIntro | IPS] (ihole N H) C :- !,
  do-iModIntro H H', !,
  do-iIntros IPS (ihole N H') C.
do-iIntros [iHyp H | IPS] IH C :-
  do-iApplyHyp H IH IHS, !,
  std.forall IHS (ih\ do-iIntros IPS ih C).
do-iIntros [iIntuitionistic iFresh | IPS] (ihole N H) C :- !,
  increase-ctx-count N NS,
  do-iIntuitionistic (iAnon N) H H', !,
  do-iIntros IPS (ihole NS H') C.
do-iIntros [iIntuitionistic (iIdent ID) | IPS] (ihole N H) C :-
  do-iIntuitionistic ID H H', !,
  do-iIntros IPS (ihole N H') C.
do-iIntros [iIntuitionistic (iList IPS) | IPSS] (ihole N H) C :-
  increase-ctx-count N NS,
  do-iIntuitionistic (iAnon N) H H', !,
  do-iDestruct (iAnon N) (iList IPS) (ihole NS H') (ih\ !, do-iIntros IPSS ih C).
do-iIntros [iList IPS | IPSS] (ihole N H) C :- !,
  increase-ctx-count N NS,
  do-iIntros [iIdent (iAnon N)] (ihole NS H) (ih\ !,
    do-iDestruct (iAnon N) (iList IPS) ih (ih'\ !,
      do-iIntros IPSS ih' C
    )
  ).
do-iIntros IPS IH _ :-
  coq.error "Failed to apply" IPS "in hole" {ihole->string IH}.