\usepackage{minted}
\usepackage{syntax}
\usepackage{csquotes}
\usepackage{xspace}
\usepackage{float}
\usepackage{ifdraft}

\usepackage{empheq}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{wasysym}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{letltxmacro}

\LetLtxMacro\amsproof\proof
\LetLtxMacro\amsendproof\endproof

\let\leftbar\@undefined
\let\endleftbar\@undefined
% \usepackage{thmtools}
% \usepackage{thm-listof}
\usepackage{tcolorbox}

\tcbuselibrary{theorems,breakable,skins,minted}

\usepackage{xcolor}

\usepackage{anysize}
\usepackage{bm}

\AtBeginDocument{%
    \LetLtxMacro\proof\amsproof
    \LetLtxMacro\endproof\amsendproof
}

\usepackage{bussproofs}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes.geometric,backgrounds,positioning,calc,matrix,chains,arrows.meta}

\usemintedstyle{default}

\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS 
\hbadness=10000 % Disable underfull hbox badness messages

%%%%%%%%%%%%%%%%% MINTED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{etoolbox}

\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother

\definecolor{bg}{rgb}{0.95,0.95,0.95}

% \newminted{elpi}{autogobble,bgcolor=bg,linenos=true,escapeinside=~~}
% \newminted{coq}{autogobble,bgcolor=bg,linenos=true,escapeinside=~~}
\newmintinline[elpii]{elpi}{}
\newmintinline[coqi]{coq}{}

\newtcblisting{coqcode}{
    listing engine=minted,
    minted language=coq,
    minted options={linenos,autogobble,escapeinside=~~},
    listing only,
    enhanced,
    sharp corners,
    breakable,
    borderline west={2pt}{0pt}{black},
    colback=black!5,
    boxrule=0pt,
    frame hidden,
    left=7mm,
    overlay={\begin{tcbclipinterior}\fill[black!20] ([xshift=2pt]frame.south west)
                rectangle ([xshift=5.5mm]frame.north west);\end{tcbclipinterior}}
}

\newtcblisting{elpicode}{
    listing engine=minted,
    minted language=elpi,
    minted options={linenos,autogobble,escapeinside=~~},
    listing only,
    enhanced,
    sharp corners,
    breakable,
    borderline west={2pt}{0pt}{black},
    colback=black!5,
    boxrule=0pt,
    frame hidden,
    left=7mm,
    overlay={\begin{tcbclipinterior}\fill[black!20] ([xshift=2pt]frame.south west)
                rectangle ([xshift=5.5mm]frame.north west);\end{tcbclipinterior}}
}

%%%%%%%%%%%%%%%%%%%%%% NAME ABREVIATIONS %%%%%%%%%%%%%%%%%%%%%%
\newcommand{\elpi}{Elpi\xspace}
\newcommand{\iris}{Iris\xspace}
\newcommand{\ce}{Coq-Elpi\xspace}
\newcommand{\coq}{Coq\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TODO NOTES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[shadow,loadshadowlibrary,textwidth=3cm,textsize=tiny,obeyFinal]{todonotes}

\newcommand{\quest}[1]{\todo[color=blue!20]{Question: #1}}
\newcommand{\todoo}[1]{\todo[color=red!20]{TODO: #1}}
\newcommand{\note}[1]{\todo[color=green!20]{Note: #1}}

\newcommand{\eg}{\emph{e.g.,}\xspace}

% \extrarowheight=\jot	% else, arrays are scrunched compared to, say, aligned
% \newcolumntype{.}{@{}}
% Array {rMcMl} modifies array {rcl}, putting mathrel-style spacing
% around the centered column. (We used this, for example, in laying
% out some of Iris' axioms. Generally, aligned is simpler but aligned
% does not work in mathpar because \\ inherits mathpar's 2em vskip.)
% The capital M stands for THICKMuskip. The smaller medmuskip would be
% right for mathbin-style spacing.
\newcolumntype{M}{@{\mskip\thickmuskip}}

%%%%%%%%%%% Reusable pieces %%%%%%%%%%%%%%%%%%%%%%

\newcommand{\MLLdelete}{\operatorname{delete}}
\newcommand{\MLLDeleteProg}{
    \begin{align*}
        \MLLdelete\,\langv{hd}\,\langv{i} =\  & \MatchML{\langv{hd}\,}with{\None}=>{()}|{\Some \loc}=>{
        \Let (\lvar, \langv{mark}, \langv{tl}) = \deref \loc in                                                                                                              \\
                                              &                                                         & \phantom{\Ra}\ \If \langv{mark} = \False\ \&\&\ \langv{i} = 0 then \\
                                              &                                                         & \phantom{\Ra}\ \quad \loc \gets (\lvar, \True, \langv{tl})         \\
                                              &                                                         & \phantom{\Ra}\ \Else \If \langv{mark} = \False then                \\
                                              &                                                         & \phantom{\Ra}\ \quad \MLLdelete\,\langv{tl}\ (\langv{i} - 1)       \\
                                              &                                                         & \phantom{\Ra}\ \Else                                               \\
                                              &                                                         & \phantom{\Ra}\ \quad \MLLdelete\,\langv{tl}\ \langv{i}
        }end{}
    \end{align*}
}
\newcommand{\isMLL}{\textlog{isMLL}}
\newcommand{\isMLLRecDef}{\isMLLDef{\isMLL}}
\newcommand{\isMLLFDef}{\isMLLDef{\pred}}

\newcommand{\isMLLDef}[1]{\ensuremath{
        \begin{array}[t]{l}
            \hd = \None * \vect{\val} = [] \lor{}                                                                      \\
            (\Exists \loc, \val', \tl. \hd = \Some l * l \fmapsto (\val', \True, \tl) * #1\, \tl\, \vect{\val}) \lor{} \\
            \left( \Exists \loc, \val', \vect{\val}'', \tl.
            \begin{array}{@{}l}
                \hd = \Some l * l \fmapsto (\val', \False, \tl)\spac * \\
                \vect{\val} = \val' :: \vect{\val}'' * #1\, \tl\, \vect{\val}''
            \end{array}
            \right)
        \end{array}
    }}

%%%%%%%%%%% math things %%%%%%%%%%%%%%%%%%

\usepackage{esvect}

\newcommand{\vect}[1]{%
    \vv{#1}%
}

\newcommand{\iindex}{i}
\newcommand{\iindexB}{j}

\newcommand{\hd}{\langv{hd}}
\newcommand{\tl}{\langv{tl}}

\newcommand{\lfp}{\ensuremath{\mu}}
\newcommand{\hopred}{\ensuremath{\textlog{F}}}
\newcommand{\hopredB}{\ensuremath{\textlog{G}}}

\newcommand{\purered}{\longrightarrow_{\text{pure}}}

\newcommand{\rel}{\ensuremath{R}}

\newcommand{\wandrel}{\ensuremath{(\wand)}}
\newcommand{\eqrel}{\ensuremath{(=)}}
\newcommand{\lorrel}{\ensuremath{(\lor)}}
\newcommand{\seprel}{\ensuremath{(*)}}

\newcommand{\respect}{\ensuremath{\bm{\Longrightarrow}}}
\newcommand{\point}{\ensuremath{\bm{\gtrdot}}}
\newcommand{\persrel}{\ensuremath{\pmb{\always}}}

\newcommand{\carprod}{\times}

\newcommand{\func}{f}
\newcommand{\funcB}{g}

\newcommand{\CoqProp}{\textdom{Prop}}
\newcommand{\pure}[1]{\ensuremath{\left\ulcorner #1 \right\urcorner}}

\newcommand*{\inferp}[3]{%
    \inferrule*[right=\ruleref{#1},vcenter]{#2}{#3}%
}

%%%%%%%%%%%%%%%%%% Theorems %%%%%%%%%%%%%%%%%%

\usepackage[noabbrev]{cleveref}


\newcounter{theorem}
\NewTcbTheorem[number within=chapter]{theorem}{Theorem}{
    label type=theorem,
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black,
    coltitle=white,
}{thm}
\NewTcbTheorem[use counter from=theorem]{lemma}{Lemma}{
    label type=lemma,
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black!60},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black!60,
    coltitle=white
}{lem}
\NewTcbTheorem[use counter from=theorem]{corollary}{Corollary}{
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black,
    coltitle=white
}{cor}
\NewTcbTheorem[no counter]{remark}{remark}{
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black,
    coltitle=white
}{rem}
% \declaretheorem[within=chapter]{theorem}
% \declaretheorem[sibling=theorem]{lemma}
% \declaretheorem[sibling=theorem]{corollary}
% \declaretheorem[numbered=no, style=remark]{remark}

\NewTcbTheorem[use counter from=theorem]{example}{Example}{
    label type=example,
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black!60},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black!60,
    coltitle=white
}{ex}
\NewTcbTheorem[use counter from=theorem]{definition}{Definition}{
    label type=definition,
    enhanced,
    sharp corners,
    breakable,  % Allows page break.
    borderline west={2pt}{0pt}{black},
    colback=black!5,  % Background color.
    boxrule=0pt,
    frame hidden,
    title={\bfseries Title},
    colbacktitle=black,
    coltitle=white
}{def}
% \declaretheorem[sibling=theorem, thmbox={bodystyle=\normalfont\noindent}]{example}
% \declaretheorem[sibling=theorem]{definition}

% \makeatletter
% \newcommand{\cutthmoff}{\thmbox@cutfalse}
% \newcommand{\cutthmon}{\thmbox@cuttrue}
% \makeatother

%%%%%%%%%%% Tikz commands %%%%%%%%%%%%%%%%%%%
\edef\sizetape{0.7cm}
\tikzset{
    basic box/.style = {
            shape = rectangle,
            draw  = #1,
            fill  = #1!25,
            rounded corners
        },
    memnode/.style={
            rectangle,
            minimum height=.6cm,
            draw,
            rounded corners
        },
    MLL/.style={
            rectangle split,
            rectangle split horizontal,
            rectangle split empty part width=.5,
            rectangle split ignore empty parts=false,
            rectangle split parts=3,
            rounded corners,
            draw,
            anchor=center
        },
    marked/.style={
            append after command={
                    [every edge/.append style={
                                    thick,
                                    black,
                                    shorten >=\pgflinewidth,
                                    shorten <=\pgflinewidth,
                                }]
                    (\tikzlastnode.one split north) edge (\tikzlastnode.two split south)
                    (\tikzlastnode.one split south) edge (\tikzlastnode.two split north)
                }
        },
    null/.style={
            append after command={
                    [every edge/.append style={
                                    thick,
                                    black,
                                    shorten >=.2cm,
                                    shorten <=.2cm,
                                }]
                    (\tikzlastnode.two split north) edge (\tikzlastnode.south east)
                    (\tikzlastnode.two split south) edge (\tikzlastnode.north east)
                }
        },
    >/.tip = Latex,
    p/.tip = Circle
}

%%%%%%%%%%%% Draft / Final %%%%%%%%%%%%%%%%%%%%
\newcommand{\outline}[1]{\ifoptionfinal{}{#1}}
