\documentclass[aspectratio=169]{beamer}

\usepackage[no-math]{fontspec}
% \usepackage{microtype}
\setmonofont{Hack}
% \newfontfamily{\fallbackfont}{DejaVu Sans Mono}
% \DeclareTextFontCommand{\textfallback}{\fallbackfont}
% \newcommand{\fallbackchar}[2][\textfallback]{%
%     \newunicodechar{#2}{#1{#2}}%
% }
% \fallbackchar{⌜}
% \fallbackchar{⌝}
 
% \usepackage{silence} 
% \WarningsOff[latexfont]

\usepackage[rgb]{xcolor}
\usepackage{url}

\usepackage{graphicx}
\usepackage[style=alphabetic, maxbibnames=99]{biblatex}
\usepackage{refcount}
\usepackage{array}
\usepackage{mathpartir}
\usepackage{pftools}
\usepackage{iris}
\usepackage{heaplang}
\usepackage{thesiscommands}

\usetheme{Frankfurt}
\usecolortheme{beaver}

\title{Extending the Iris Proof Mode with Inductive Predicates using Elpi}
\author{Luko van der Maas}
\institute{Computing Science\\Radboud University}
\date{}
 

\begin{document}
\frame{\titlepage}

\section{Introduction}
\begin{frame}{Program verification}
    \begin{itemize}
        \item Verify programs by specifying pre and post conditions
        \item Specification happens in separation logic
    \end{itemize}
\end{frame}

\begin{frame}{Separation logic with Hoare triples}
    \begin{center}
        \begin{tikzpicture}[remember picture]
            \node (hoare) at (0,0) {$\hoare{\isD\, d\; y}{\subnode{op}{\textlog{op}}\, d\; x }{\isD\, d\; (\subnode{f}{\textlog{f}}\, x\; y)}$};
            \node[align=left] (oplabel) at (-1, -1) {Imperative\\program};
            \node[align=left] (flabel) at (1,-1) {Functional\\program};
            \node (isdlabel) at (0, 1) {Representation predicate};

            \draw[->] (oplabel) -- (op);
            \draw[->] (flabel) -- (f);
        \end{tikzpicture}
    \end{center}
    \[\hoare{\isList\, \hd\, \vect{\val}}{\MLLdelete\, \hd\; \iindex }{\isList\, \hd\; (\textlog{remove}\, \iindex\, \vect{\val})}\]
\end{frame}

\begin{frame}{Representation predicates}
    \begin{center}
        \begin{tikzpicture}
            \node [MLL] (x0) at (0,0) {$\val_0$};
            \node [MLL, marked] (x1) at (3,0) {$\val_1$};
            \node [MLL] (x2) at (6,0) {$\val_2$};
            \node [MLL, null] (x3) at (9,0) {$\val_3$};

            \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x0.three) edge [bend left] (x1.west);
            \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x1.three) edge [bend left] (x2.west);
            \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x2.three) edge [bend left] (x3.west);

            \node (l) [above=of x0.west] {$\loc$};
            \path[->,thick] (l) edge ([yshift=.1cm]x0.north west);
        \end{tikzpicture}
    \end{center}

    \begin{align*}
        \isMLL\, \hd\, \vect{\val} & =
        \isMLLRecDef
    \end{align*}
\end{frame}

\begin{frame}[fragile]{Outline of our solution}
    \begin{coqcode}
        eiInd
        Inductive is_MLL : val → list val → iProp :=
            | empty_is_MLL : is_MLL NONEV []
            | mark_is_MLL v vs l tl : 
              l ↦ (v, #true, tl) -∗ is_MLL tl vs -∗ 
              is_MLL (SOMEV #l) vs
            | cons_is_MLL v vs tl l : 
              l ↦ (v, #false, tl) -∗ is_MLL tl vs -∗ 
              is_MLL (SOMEV #l) (v :: vs).
      \end{coqcode}
\end{frame}

\begin{frame}{Approach}

\end{frame}

\begin{frame}{Contributions}
    \begin{itemize}
        \item Created system for defining and using inductive predicates in the IPM
        \item Strategy for modular tactics in Elpi
        \item Generating monotonicity proof of pre fixpoint function
        \item Evaluation of Elpi as meta-programming language for the IPM
    \end{itemize}
\end{frame}

\section{Theory}

\section{Implementation}

\section{Demo}
\begin{frame}{Demo}

\end{frame}

\section{Evaluation}

\section{Conclusion}
\begin{frame}{Conclusion}

\end{frame}

\begin{frame}{Future work}

\end{frame}

\end{document}