\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Background on separation logic}

In this chapter we give a background on separation logic by specifying and proving the correctness of a program on marked linked lists (MLLs), as seen in \cref*{ch:introduction}. First we will set up the example we will discuss in this chapter in \cref*{sec:irissetup}. Next, we will be looking at separation logic as we will use it in the rest of this thesis in \cref*{sec:seplogic}. Then, we show how to give specifications using Hoare triples and weakest preconditions in \cref*{sec:Hoare}. Next, we will show how we can create a predicate used to represent a data structure for our example in \cref*{sec:represpreds}. Lastly, we will finish the specification and proof of a program manipulating marked linked lists in \cref*{sec:proofmll}.

\section{Setup}
\label{sec:irissetup}
We will be defining a program that deletes an element at an index in a MLL as our example for this chapter. This program is written in HeapLang, a higher order, untyped, ML-like language. HeapLang supports many concepts around both concurrency and higher-order heaps (storing closures on the heap), however, we won't need any of these features. It can thus be treated as a basic ML-like language. The syntax together with any syntactic sugar can be found in \cref*{fig:heaplangsyntax}. For more information about HeapLang one can reference the Iris technical reference \cite*{iristeamIrisReference2023}.

\begin{figure}[ht]
  \begin{center}
    \begin{align*}
      \val,\valB \in \Val \bnfdef{}       &
      z \mid
      \True \mid \False \mid
      \TT \mid
      \poison \mid
      \loc \mid                     \hspace*{2cm} (z \in \integer, \loc \in \Loc)                                        \\&
      (\val,\valB)_\valForm \mid
      \InlV(\val) \mid
      \InrV(\val)                                                                                                        \\
      \expr \in \Expr \bnfdef{}           &
      \val \mid
      \lvar \mid
      \expr_1(\expr_2) \mid
      {}
      \HLOp_1 \expr \mid
      \expr_1 \HLOp_2 \expr_2 \mid                                                                                       \\ &
      \If \expr then \expr_1 \Else \expr_2 \mid
      {}                                                                                                                 \\ &
      (\expr_1,\expr_2)_\exprForm \mid
      \Fst(\expr) \mid
      \Snd(\expr) \mid
      {}                                                                                                                 \\ &
      \InlE(\expr) \mid
      \InrE(\expr) \mid                                                                                                  \\ &
      \Match \expr with \Inl(\lvar) => \expr_1 | \Inr(\lvarB) => \expr_2 end \mid
      {}                                                                                                                 \\ &
      \Alloc(\expr_1,\expr_2) \mid
      \deref \expr \mid
      \expr_1 \gets \expr_2                                                                                              \\
      \HLOp_1 \bnfdef{}                   & - \mid \ldots ~~\text{(list incomplete)}                                     \\
      \HLOp_2 \bnfdef{}                   & + \mid - \mid \Ptradd \mid \mathop{=} \mid \ldots ~~\text{(list incomplete)}
      \\\\
      \Let \lvar = \expr in \expr' \eqdef & (\Lam \lvar. \expr')(\expr)                                                  \\
      \None \eqdef                        & \InlV(\TT)                                                                   \\
      \Some \val \eqdef                   & \InrV(\val)                                                                  \\
      \expr; \expr' \eqdef{}              & \Let \any = \expr in \expr'
    \end{align*}
    \caption{Fragment of the syntax of HeapLang as used in the examples with at the bottom syntactic sugar being used}
    \label{fig:heaplangsyntax}
  \end{center}
\end{figure}

The program we will be using as an example will delete an index out of the list by marking that node, thus logically deleting it.
\MLLDeleteProg
The program is a function called $\textlog{delete}$, the function has two arguments. The first argument $\loc$ is either $\None$, for the empty list, or $\Some \langv{hd}$ where $\langv{hd}$ is a pointer to a MLL. HeapLang has no null pointers, thus we use $\None$ as the null pointer. The second argument is the index in the MLL to delete. The first step this recursive function does in check whether the list we are deleting from is empty or not. We thus match $\loc$ on either $\None$, the MLL is empty, or on $\Some\,\langv{hd}$, where $\langv{hd}$ becomes the pointer to the MLL and the MLL contains some nodes. If the list is empty, we are done and return unit. If the list is not empty, we load the first node and save it in the three variables $\lvar$, $\langv{mark}$ and $\langv{tl}$. Now, $\lvar$ contains the first element of the list, $\langv{mark}$ tells us whether the element is marked, thus logically deleted, and $\langv{tl}$ contains the reference to the tail of the list. We now have three different options for our list.
\begin{itemize}
  \item If our index is zero and the element is not marked, thus logically deleted, we want to delete it. We write to the $\langv{hd}$ pointer our node, but with the mark bit set to $\True$, thus logically deleting it.
  \item If the mark bit is $\False$, but the index to delete, $\iindex$, is not zero. The current node has not been deleted, and thus we want to decrease $\iindex$ by one and recursively call our function $\operatorname{f}$ on the tail of the list.
  \item Lastly if the mark bit is set to $\True$, we want to ignore this node and continue to the next one. We thus call our recursive function $\operatorname{f}$ without decreasing $\iindex$.
\end{itemize}
$\MLLdelete\, \loc\, 1$ will thus apply the transformation below.
\begin{center}
  \begin{tikzpicture}
    \begin{scope}
      \node [MLL] (x0) at (0,0) {$\val_0$};
      \node [MLL, marked] (x1) at (3,0) {$\val_1$};
      \node [MLL] (x2) at (6,0) {$\val_2$};
      \node [MLL, null] (x3) at (9,0) {$\val_3$};

      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x0.three) edge [bend left] (x1.west);
      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x1.three) edge [bend left] (x2.west);
      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x2.three) edge [bend left] (x3.west);

      \node (l) [above=of x0.west] {$\loc$};
      \path[->,thick] (l) edge ([yshift=.1cm]x0.north west);
    \end{scope}
    \path[->,thick] (4.5,-1) edge[double,double distance=2pt] node[right] {$\MLLdelete\, \loc\, 1$} (4.5,-2);
    \begin{scope}[yshift=-3cm]
      \node [MLL] (x0) at (0,0) {$\val_0$};
      \node [MLL, marked] (x1) at (3,0) {$\val_1$};
      \node [MLL, marked] (x2) at (6,0) {$\val_2$};
      \node [MLL, null] (x3) at (9,0) {$\val_3$};

      \path[p->,thick] ([yshift=1pt,xshift=1pt]x0.three) edge [bend left] (x1.west);
      \path[p->,thick] ([yshift=1pt,xshift=1pt]x1.three) edge [bend left] (x2.west);
      \path[p->,thick] ([yshift=1pt,xshift=1pt]x2.three) edge [bend left] (x3.west);

      \node (l) [above=of x0.west] {$\loc$};
      \path[->,thick] (l) edge ([yshift=.1cm]x0.north west);
    \end{scope}
  \end{tikzpicture}
\end{center}
A tuple is shown here as three boxes next to each other, the first box contains a value. The second box is a boolean, it is true, thus marked, if it is crossed out. The third box is a pointer, denoted by either a cross, a null pointer, or a circle with an arrow pointing to the next node.

When thinking about it in terms of lists, $\MLLdelete\, \loc\, 1$ deletes from the list $[\val_0, \val_2, \val_3]$ the element $\val_2$, thus resulting in the list $[\val_0, \val_3]$.
In the next section we will show how separation logic can be used to reason about sections of memory, such as shown above.

\section{Separation logic}
\label{sec:seplogic}
\begin{itemize}
  \item Separation logic is a logic that allows us to represent the state of memory in a higher order predicate logic
  \item The syntax is
\end{itemize}
\todoo{What are $\expr$ and $\val$}
\begin{align*}
  \prop \in \iProp \bnfdef{} & \FALSE \mid \TRUE \mid \prop \land \prop \mid \prop \lor \prop \mid \prop \Ra \prop \mid \Exists \var:\type. \prop \mid \All \var:\type. \prop \mid \\
                             & \loc \fmapsto \val \mid \prop * \prop \mid \prop \wand \prop \mid \always\prop \mid \wpre\expr{\pred}                                               \\
\end{align*}
\begin{itemize}
  \item We will sometimes write $\wpre\expr{\pred}$ as $\wpre\expr{\Ret\val. \prop}$ where $\pred$ is a predicate that takes a value
  \item It contains the normal higher order predicate logic connectives on the first line
  \item The first two connectives on the second line will be discussed in this section
  \item The last three connectives on the second line will be discussed in \cref*{sec:Hoare}
  \item We start with points to, $\fmapsto$
\end{itemize}
\begin{center}
  \begin{tikzpicture}
    \node[memnode] (x) at (0,0) {$\val$};
    \node (l) [above=of x.west] {$\loc$};

    \path[->, thick] (l) edge ([yshift=.1cm]x.north west);
    \node (logic) at (3,0.8) {$\loc\fmapsto\val$};
  \end{tikzpicture}
\end{center}
\begin{itemize}
  \item Picture of memory with $\loc\fmapsto \val$ next to it
  \item $\loc\fmapsto\val$ means we own a location in memory, $l$, and it has value $\val$
  \item $\land$ now no longer works as expected
  \item introduce ∗
\end{itemize}
\begin{center}
  \begin{tikzpicture}
    \node[memnode] (x) at (0,0) {$\val$};
    \node (l) [above=of x.west] {$\loc$};

    \path[->, thick] (l) edge ([yshift=.1cm]x.north west);
    \path (0.5,-.8) edge[dashed] node[fill=white] {\large$*$} (0.5,1.8);
    \begin{scope}[xshift=1.2cm]
      \node[memnode] (y) at (0,0) {$\valB$};
      \node (k) [above=of y.west] {$\locB$};

      \path[->, thick] (k) edge ([yshift=.1cm]y.north west);
    \end{scope}
    \node (logic) at (4,0.8) {$\loc\fmapsto\val\ ∗\ \locB\fmapsto\valB$};
  \end{tikzpicture}
\end{center}
\begin{itemize}
  \item Describe rules of $*$
\end{itemize}
\begin{mathpar}
  \begin{array}{rMcMl}
    \TRUE * \prop             & \provesIff & \prop                     \\
    \prop * \propB            & \proves    & \propB * \prop            \\
    (\prop * \propB) * \propC & \proves    & \prop * (\propB * \propC)
  \end{array}
  \and
  \infer[$*$-mono]
  {\prop_1 \proves \propB_1 \and
    \prop_2 \proves \propB_2}
  {\prop_1 * \prop_2 \proves \propB_1 * \propB_2}
\end{mathpar}
\begin{itemize}
  \item This does not include $\prop \proves \prop * \prop$
\end{itemize}

\section{Writing specifications of programs}
\label{sec:Hoare}
\begin{itemize}
  \item We will discuss how to specify the actions of a program
  \item $\MLLdelete$ will be the example
  \item The goal will be total correctness
  \item Guarantee that given some preconditions in separation logic hold, the program will terminate and some postconditions in separation logic hold and $\expr$ is safe
  \item Typically use Hoare triples
\end{itemize}
\[\hoare{\prop}{\expr}{\pred}\]
\begin{itemize}
  \item Given that $\prop$ holds
  \item $\expr$ terminates
  \item returns $\val$
  \item $\pred(\val)$ now holds
  \item We often write $\hoare{\prop}{\expr}{\Ret\val. \propB}$, thus leaving out a $\lambda$
  \item We can also write a value for $\val$ to express that the returned value is that value
  \item Thus the specification of $\loc\gets\valB$ becomes
\end{itemize}
\begin{align*}
  \hoare{\loc\fmapsto\val}{\loc\gets\valB}{().\ \loc\fmapsto\valB}
\end{align*}
\begin{itemize}
  \item The precondition of our specification is that there is a location $\loc$ that has value $\val$
  \item Then, $\loc\gets\valB$ return unit
  \item New state of memory is $\loc\fmapsto\valB$
  \item The Hoare triple of $\MLLdelete$ is
\end{itemize}
\begin{align*}
  \hoare{\textlog{isMLL}\, \langv{hd}\, \vect{\val}}{\MLLdelete\, \langv{hd}\; \iindex }{().\ \textlog{isMLL}\, \langv{hd}\; (\textlog{remove}\, \iindex\, \vect{v})}
\end{align*}
\begin{itemize}
  \item This uses a predicate we will talk more about in \cref*{sec:represpreds}
  \item It tells is that the MLL in memory at $\langv{hd}$ is represented by the list of value $\vect{v}$
  \item remove is the function on mathematical lists that removes the element at index $i$ from the list $\vect{v}$
\end{itemize}
\paragraph{WP} \todoo{better title}

\begin{itemize}
  \item There is a second way to specify programs
  \item We use weakest preconditions, $\wpre{\expr}{\pred}$
  \item The weakest precondition states that expression $\expr$ is safe to execute, terminates with value $\val$ and afterwards $\pred(\val)$ holds.
  \item We use the same way of writing predicates in the weakest precondition as with Hoare triples
  \item There is precondition in the weakest preconditions, instead we add that using the magic wand
  \item We add that using the magic wand, $\prop \wand \wpre{\expr}{\pred}$
  \item Magic wand is implication that reasons about resources
  \item $\propB \wand \propC$ describes resources where if we add $\propB$ we get $\propC$
  \item as can bee seen in the below law
\end{itemize}
\begin{mathpar}
  \inferhrefB{$\wand$I-E}{wand-IE}
  {\prop * \propB \proves \propC}
  {\prop \proves \propB \wand \propC}
\end{mathpar}
\begin{itemize}
  \item This law works both ways.
  \item Thus, using the magic wand we add that if we have $\prop$ then $\wpre{e}{\pred}$ holds.
  \item Thus, if we want to specify $\loc\gets\val$ using weakest precondition we use the rule \ruleref{wp-store} in \cref*{fig:wp-rules}
  \item To prove, $\wpre{(\loc \gets \valB)}{\pred}$, we have to prove that $\loc \fmapsto \val$ holds and $\loc \fmapsto \valB \wand \pred\TT$. In other words, if we add that $\loc \fmapsto \valB$ holds, $\pred\TT$ should hold.
  \item Besides rules about specific expression we also have general rules about the weakest precondition
  \item \ruleref{wp-value} is used when a program is finished
  \item \ruleref{wp-mono} allows us to transform the post condition of $\textlog{wp}$
  \item \ruleref{wp-frame} allows us to ??? \quest{what does this again}
  \item \ruleref{wp-bind} can extract the expression that is to be executed inside the whole expression using the possible contexts
\end{itemize}

\begin{figure}[H]
  Structural rules.
  \begin{mathpar}
    \inferH{wp-value}
    {}{\pred(\val) \proves \wpre{\val}{\pred}}

    \inferH{wp-mono}
    {\forall v. \Phi(v) \proves \Psi(v)}
    {\wpre{e}{\Phi} \proves \wpre{e}{\Psi}}

    \inferH{wp-frame}
    {}{\propB * \wpre\expr{\Ret\var.\prop} \proves \wpre\expr{\Ret\var.\propB*\prop}}

    \inferH{wp-bind}
    {}
    {\wpre\expr{\Ret\var. \wpre{\lctx[\var]}{\pred}} \proves \wpre{\lctx[\expr]}{\pred}}
  \end{mathpar}
  Rules for basic language constructs.
  \begin{mathpar}
    \inferH{wp-alloc}
    { }
    {\All \loc. \loc \fmapsto \val \wand {\pred(\loc)} \proves \wpre{\Alloc(\val)}{\pred}}
    \and
    \inferH{wp-load}
    { }
    {\loc \fmapsto \val *\loc \fmapsto \val \wand \pred(\val)\proves \wpre{\deref \loc}{\pred}}
    \and
    \inferH{wp-store}
    { }
    {\loc \fmapsto \val * (\loc \fmapsto \valB \wand \pred\TT) \proves \wpre{(\loc \gets \valB)}{\pred}}
    \and
    \inferH{wp-pure}
    {\expr \purered \expr' \and \wpre{\expr'}{\pred}}
    {\wpre{\expr}{\pred}}
  \end{mathpar}
  Pure reductions.
  \begin{mathpar}
    (\textlog{f}\,\lvar := \expr) \val \purered \expr[\val/\lvar][\textlog{f}\,\lvar := \expr/\textlog{f}]
    \and
    \If\True then \expr_1 \Else \expr_2 \purered \expr_1
    \and
    \If\False then \expr_1 \Else \expr_2 \purered \expr_2
    \and
    \Fst(\val_1,\val_2) \purered \val_1
    \and
    \Snd(\val_1,\val_2) \purered \val_2
    \and
    \infer
    {\HLOp_1 \val = \valB}
    {\HLOp_1 \val \purered \valB}
    \and
    \infer
    {\val_1 \HLOp_2 \val_2 = \val_3}
    {\val_1 \HLOp_2 \val_2 \purered \val_3}
    \and
    \Match\InlV\val with \Inl\lvar => \expr_1 | \Inr\lvar => \expr_2 end \purered \expr_1[\val/\lvar]
    \and
    \Match\InrV\val with \Inl\lvar => \expr_1 | \Inr\lvar => \expr_2 end \purered \expr_2[\val/\lvar]
  \end{mathpar}
  Context rules
  \begin{align*}
    \lctx \in \Lctx \bnfdef{} &
    \bullet \mid
    \expr\, \lctx \mid
    \lctx\, \val \mid
    \HLOp_1 \lctx \mid
    \expr \HLOp_2 \lctx \mid
    \lctx \HLOp_2 \val \mid
    \If \lctx then \expr_1 \Else \expr_2 \mid
    {}                          \\ &
    (\expr, \lctx) \mid
    (\lctx, \val) \mid
    \Fst(\lctx) \mid
    \Snd(\lctx) \mid
    {}                          \\ &
    \Inl(\lctx) \mid
    \Inr(\lctx) \mid
    \Match \lctx with \Inl => \expr_1 | \Inr => \expr_2 end \mid
    {}                          \\ &
    \AllocN(\expr, \lctx) \mid
    \AllocN(\lctx, \val) \mid
    \Free(\lctx) \mid
    \deref \lctx \mid
    \expr \gets \lctx \mid
    \lctx \gets \val \mid
  \end{align*}
  \caption{Rules for the weakest precondition assertion.}
  \label{fig:wp-rules}
\end{figure}
\todoo{Explain why Hoare does not work, but wp does}
\begin{itemize}
  \item Thus we define the hoare triple as a weakest precondition
  \item Only use weakest pre-conditions in our proofs
\end{itemize}
\begin{mathpar}
  \inferH{Hoare-def}
  {}
  {\hoare{P}{e}{\pred} \eqdef \always (P \wand \wpre{e}{\pred})}
\end{mathpar}
\begin{itemize}
  \item We make use of new connective, $\always$
  \item Our weakest precondition with its precondition are wrapped in a box, making the proposition persistent
  \item Any persistent proposition has the property that once we know it holds, it always holds
  \item As can be seen by the rule \ruleref{pers-dup} below
  \item We are allowed to duplicate any persistent proposition
  \item We do have to prove that it is persistent
  \item To prove a proposition persistent we can only use persistent proposition in our assumptions as can be seen in the rule \ruleref{pers-mono} below
  \item Other rules about persistent proposition can be seen below
\end{itemize}
\begin{mathpar}
  \inferhref{$\always$-dup}{pers-dup}
  {}
  {\always{\prop} \provesIff \always{\prop} * \always{\prop}}

  \inferhref{$\always$-sep}{pers-sep}
  {}
  {\always{\prop * \propB} \provesIff \always{\prop} * \always{\propB}}

  \inferhref{$\always$-mono}{pers-mono}
  {\prop \proves \propB}
  {\always{\prop} \proves \always{\propB}}

  \inferhref{$\always$-E}{pers-elim}
  {}
  {\always\prop \proves \prop}

  \inferhref{$\always$-distr}{pers-distr}
  {}
  {\always{\prop} \land \propB \proves \always{\prop} * \propB}

  \begin{array}[c]{rMcMl}
    \always{\prop}            & \proves & \always\always\prop       \\
    \All x. \always{\prop}    & \proves & \always{\All x. \prop}    \\
    \always{\Exists x. \prop} & \proves & \Exists x. \always{\prop}
  \end{array}
\end{mathpar}
\begin{itemize}
  \item From the definition of a hoare triple we now know it is persistent
  \item This is needed since we have a higher order heap, we can store closures
  \item Take the following function with its specification below
\end{itemize}
\begin{align*}
   & \operatorname{refadd}\, n\ :=\ \Lam \loc. \loc \gets \deref \loc + n                                                          \\
   & \hoare{\TRUE}{\operatorname{refadd}\, n}{\Ret f. {\forall \loc.\ \hoare{\loc \fmapsto m}{f\, \loc}{\Ret (). \loc\fmapsto n}}}
\end{align*}
\begin{itemize}
  \item The program takes a value $n$ and then returns a closure which we can call with a pointer to add $n$ to the value of that pointer
  \item We can now use this function in a program like below
\end{itemize}
\begin{align*}
   & \Let f = \operatorname{refadd}\, 10 in \\
   & \Let \loc = \Alloc 0 in                \\
   & f\, \loc; f\, \loc                     \\
   & \deref \loc
\end{align*}
\begin{itemize}
  \item Now since we can't duplicate resources and resources are used up once use, once we gain from the specification of $\operatorname{addref}$ that $f$ has specification $\hoare{\loc \fmapsto m}{f\, \loc}{\Ret (). \loc\fmapsto n}$
  \item If a hoare triple was not persistent, we could only use this specification once
  \item Thus we could not verify what would happen the second time we call $f$.
  \item But since they are we can use \ruleref{pers-dup} to duplicate the specification of $f$ and use it twice
  \item Thus we can prove that the above program returns 20
\end{itemize}
\section{Representation predicates}
\label{sec:represpreds}
The goal in specifying programs is to connect the world in which the program lives to the mathematical world. In the mathematical world we are able to create proves and by linking the program world to the mathematical world we can prove properties of the program. \todoo{Maybe move the first part of this section to an earlier section}

We have shown in the previous two sections how one can represent simple states of memory in a logic and reason about it together with the program. However, this does not easily scale to more complicated data types, especially recursive datatypes. One such datatype is the MLL. We want to connect a MLL in memory to a mathematical list. In \cref*{sec:Hoare} we used the predicate $\textlog{isMLL}\, \langv{hd}\, \vect{v}$, which tells us that the in the memory starting at $\langv{hd}$ we can find a MLL that represents the list $\vect{v}$. In this section we will show how such a predicate can be used.

\begin{itemize}
  \item We need an inductive predicate to reason about a recursive structure
  \item For $\textlog{isMLL}\,(\Some\loc)\,[x_0,x_2,x_3]$ look below
\end{itemize}
\begin{center}
  \begin{tikzpicture}
    \begin{scope}
      \node [MLL] (x0) at (0,0) {$x_0$};
      \node [MLL, marked] (x1) at (3,0) {$x_1$};
      \node [MLL] (x2) at (6,0) {$x_2$};
      \node [MLL, null] (x3) at (9,0) {$x_3$};

      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x0.three) edge [bend left] (x1.west);
      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x1.three) edge [bend left] (x2.west);
      \path[{Circle}->,thick] ([yshift=1pt,xshift=1pt]x2.three) edge [bend left] (x3.west);

      \node (l) [above=of x0.west] {$l$};
      \path[->,thick] (l) edge ([yshift=.1cm]x0.north west);
    \end{scope}
  \end{tikzpicture}
\end{center}
\begin{itemize}
  \item Our end goal should work like below
  \item this does not work because it is not necessarily finite? \quest{This is correct right, and is Coq the reason why it has to be finite?}
\end{itemize}

\begin{align*}
  \textlog{isMLL}\, \langv{hd}\, \vect{\val} & =
  \begin{array}{cl}
         & \langv{hd} = \None * \vect{\val} = []                                                                                                                \\
    \lor & \langv{hd} = \Some l * l \fmapsto (\val, \True, \langv{tl}) * \textlog{isMLL}\, \langv{tl}\, \vect{\val}                                             \\
    \lor & \langv{hd} = \Some l * \vect{\val} = [\val'] + \vect{\val}'' * l \fmapsto (\val', \False, \langv{tl}) * \textlog{isMLL}\, \langv{tl}\, \vect{\val}''
  \end{array}
\end{align*}
\begin{itemize}
  \item We first turn our desired predicate into a functor
  \item It transforms a predicate $\pred$ into a predicate that applies $\pred$ to the tail of the MLL if it exists \todoo{write more correct}
\end{itemize}

\begin{align*}
  \textlog{isMLLPre}\, \pred\, \langv{hd}\, \vect{v} & \eqdef
  \begin{array}{rl}
         & \langv{hd} = \None * \vect{v} = []                                                                                                         \\
    \lor & \langv{hd} = \Some l * l \fmapsto (\val', \True, \langv{tl}) * \pred\, \langv{tl}\, \vect{v}                                               \\
    \lor & \langv{hd} = \Some l * \vect{\val} = [\val'] + \vect{\val}'' * l \fmapsto (\val', \False, \langv{tl}) * \pred\, \langv{tl}\, \vect{\val}''
  \end{array}
\end{align*}
\begin{itemize}
  \item This gets rid of the possible infinite nature of the statement
  \item but not strong enough
  \item we want to find a $\pred$ such that
\end{itemize}
\begin{align*}
  \All \langv{hd}\, \vect{v}. \textlog{isMLLPre}\, \pred\, \langv{hd}\, \vect{v} \wandIff \pred\, \langv{hd}\, \vect{v}
\end{align*}
\begin{itemize}
  \item This is the fixpoint of $\textlog{isMLLPre}$
  \item Use Knaster-Tarski Fixpoint Theorem to find this fixpoint \cite*{tarskiLatticetheoreticalFixpointTheorem1955}
  \item Specialized to the lattice on predicates
\end{itemize}
\begin{theorem}[Knaster-Tarski Fixpoint Theorem]
  \label{thm:tarski}
  Let $\hopred\colon (\sigax \to \iProp) \to (\sigax \to \iProp)$ be a monotone predicate, then
  \[\lfp\, \hopred\, \var \eqdef \All \Phi. (\All \var. \hopred\, \pred\, \var \wand \pred\, \var) \wand \pred \, \var\]
  defines the least fixpoint of $\hopred$
\end{theorem}
\quest{Where to introduce $\iProp$?}
\begin{itemize}
  \item Monotone is defined as
\end{itemize}
\begin{definition}[Monotone predicate]
  Any $\hopred$ is monotone when for any $\pred, \predB\colon A \to \iProp$, it holds that
  \[\always(\All \var. \pred\var \wand \predB\var) \wand \All \var. \hopred\pred\var \wand \hopred\pred\var\]
\end{definition}
\begin{itemize}
  \item In general $\hopred$ is monotone if all occurrences of its $\pred$ are positive
  \item This is the case for $\textlog{isMLL}$
  \item We can expand \cref*{thm:tarski} to predicates of type $\hopred\colon (\sigax \to B \to \iProp) \to (\sigax \to B \to \iProp)$
  \item Thus the fixpoint exists and is
\end{itemize}
\begin{align*}
  \lfp\, \textlog{isMLLPre}\, \langv{hd}\, \vect{v} & = \All \Phi. (\All \langv{hd}'\, \vect{v}'. \textlog{isMLLPre}\, \pred\, \langv{hd}'\, \vect{v}' \wand \pred\, \langv{hd}'\, \vect{v}') \wand \Phi \, \langv{hd}\, \vect{v}
\end{align*}
\begin{itemize}
  \item We can now redefine $\textlog{isMLL}$ as
\end{itemize}
\begin{align*}
  \textlog{isMLL}\, \langv{hd}\, \vect{v} \eqdef \lfp\, \textlog{isMLLPre}\, \langv{hd}\, \vect{v}
\end{align*}
\begin{itemize}
  \item Using the least fixpoint we can now define some additional lemmas
\end{itemize}
\begin{lemma}[$\lfp\, \hopred$ is the least fixpoint on $\hopred$]
  Given a monotone $\hopred\colon (\sigax \to \iProp) \to (\sigax \to \iProp)$, it holds that
  \[\All\var.\hopred\,(\lfp\,\hopred)\,\var \wandIff \lfp\,\hopred\,\var\]
\end{lemma}
\begin{lemma}[least fixpoint induction principle]
  Given a monotone $\hopred\colon (\sigax \to \iProp) \to (\sigax \to \iProp)$, it holds that
  \[\always(\All\var.\hopred\,\pred\,\var \wand \pred\,\var) \wand \All\var. \lfp\,\hopred\,\var \wand \pred\,\var\]
\end{lemma}
\begin{lemma}[least fixpoint strong induction principle]
  Given a monotone $\hopred\colon (\sigax \to \iProp) \to (\sigax \to \iProp)$, it holds that
  \[\always(\All\var.\hopred\,(\Lam\varB. \pred\,\varB \land \lfp\,\hopred\,\varB)\,\var \wand \pred\,\var) \wand \All\var. \lfp\,\hopred\,\var \wand \pred\,\var\]
\end{lemma}
\todoo{Maybe on $\textlog{isMLL}$ example}


\section{Proof of delete in MLL}
\label{sec:proofmll}
In this section we will proof the specification of $\MLLdelete$. Recall the definition of $\MLLdelete$.
\MLLDeleteProg
\\
\begin{lemma}
  For any list $\vect{\val}$ of values and $\langv{hd}\in\Val$,
  \[
    \hoare{\textlog{isMLL}\, \langv{hd}\, \vect{\val}}{\MLLdelete\, \langv{hd}\; \iindex }{().\ \textlog{isMLL}\, \langv{hd}\; (\textlog{remove}\, \iindex\, \vect{v})}
  \]
\end{lemma}
\begin{proof}
  We first use the definition of a Hoare triple, \ruleref{Hoare-def}, to create the associated weakest precondition.
  We thus need to proof that
  \[\always(\textlog{isMLL}\, \langv{hd}\, \vect{\val} \wand \wpre{\MLLdelete\, \langv{hd}\; \iindex}{().\ \textlog{isMLL}\, \langv{hd}\; (\textlog{remove}\, \iindex\, \vect{v})})\]
  We can use \ruleref{pers-mono} and \ruleref{wand-IE} to assume
  $\textlog{isMLL}\, \langv{hd}\, \vect{\val}$, and we now have to proof
  \[\wpre{\MLLdelete\, \langv{hd}\; \iindex}{().\ \textlog{isMLL}\, \langv{hd}\; (\textlog{remove}\, \iindex\, \vect{v})}\]
  And we can do induction on $\textlog{isMLL}\, \langv{hd}\, \vect{\val}$ for any $\iindex$ using the induction principle defined in \cref*{??}, and get three cases.
  \begin{description}
    \item[Case Empty MLL:] We know that $\langv{hd} = \None$ and $\vect{\val} = []$, thus we need to prove the following
      \[\wpre{\MLLdelete\, \None\; \iindex}{().\ \textlog{isMLL}\, \None\; (\textlog{remove}\, \iindex\, [])}\]
      We can now repeatedly use the \ruleref{wp-pure} and \ruleref{wp-bind} rules and finish with the rule \ruleref{wp-value} to arrive at the following statement that we have to prove.
      \[\textlog{isMLL}\, \None\; (\textlog{remove}\, \iindex\, [])\]
      This follows from the definition of $\textlog{isMLL}$
    \item[Case Marked Head:] We know that $\langv{hd} = \Some \loc$ and $\loc \fmapsto (\val', \True, \langv{tl})$ with disjointed as IH the following.
      \[\All \iindex. \wpre{\MLLdelete\, \langv{tl}\; \iindex}{().\ \textlog{isMLL}\, \langv{tl}\; (\textlog{remove}\, \iindex\, \vect{\val})} \land \textlog{isMLL}\, \langv{tl}\, \vect{\val}\]
      Thus, we need to prove that
      \[\wpre{\MLLdelete\, (\Some \loc)\; \iindex}{().\ \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, \vect{v})}\]
      By repeatedly using the \ruleref{wp-pure} and \ruleref{wp-bind} rules, we get that we need to prove
      \[\wpre{
          \left(
          \begin{array}{l}
              \Let (\lvar, \langv{mark}, \langv{tl}) = \deref \loc in \\
              \If \langv{mark} = \False\ \&\&\ \iindex = 0 then       \\
              \quad \loc \gets (\lvar, \True, \langv{tl})             \\
              \Else \If \langv{mark} = \False then                    \\
              \quad \MLLdelete\,\langv{tl}\ (\iindex - 1)             \\
              \Else                                                   \\
              \quad \MLLdelete\,\langv{tl}\ \iindex
            \end{array}
          \right)
        }{().\ \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, \vect{v})}\]
      Recall that let statements are defined in terms of lambda expressions, we can thus use \ruleref{wp-bind} with as context
      \[\lctx = \left(\begin{array}{l}
            \Let (\lvar, \langv{mark}, \langv{tl}) = \bullet in \\
            \If \langv{mark} = \False\ \&\&\ \iindex = 0 then   \\
            \quad \loc \gets (\lvar, \True, \langv{tl})         \\
            \Else \If \langv{mark} = \False then                \\
            \quad \MLLdelete\,\langv{tl}\ (\iindex - 1)         \\
            \Else                                               \\
            \quad \MLLdelete\,\langv{tl}\ \iindex
          \end{array}\right)\]
      We get the following statement we need to prove
      \[\wpre{ \deref \loc}{\val.\ \wpre{\left(
            \begin{array}{l}
                \Let (\lvar, \langv{mark}, \langv{tl}) = \val in  \\
                \If \langv{mark} = \False\ \&\&\ \iindex = 0 then \\
                \quad \loc \gets (\lvar, \True, \langv{tl})       \\
                \Else \If \langv{mark} = \False then              \\
                \quad \MLLdelete\,\langv{tl}\ (\iindex - 1)       \\
                \Else                                             \\
                \quad \MLLdelete\,\langv{tl}\ \iindex
              \end{array}
            \right)}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, \vect{v})}}\]
      And we can use \ruleref{wp-load} with $\loc \fmapsto (\val, \True, \langv{tl})$ and \ruleref{wand-IE} to get our new statement to prove:
      \[
        \wpre{\left(
          \begin{array}{l}
              \Let (\lvar, \langv{mark}, \langv{tl}) = (\val, \True, \langv{tl}) in \\
              \If \langv{mark} = \False\ \&\&\ \iindex = 0 then                     \\
              \quad \loc \gets (\lvar, \True, \langv{tl})                           \\
              \Else \If \langv{mark} = \False then                                  \\
              \quad \MLLdelete\,\langv{tl}\ (\iindex - 1)                           \\
              \Else                                                                 \\
              \quad \MLLdelete\,\langv{tl}\ \iindex
            \end{array}
          \right)}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, \vect{v})}
      \]
      We again repeatedly use \ruleref{wp-pure} with \ruleref{wp-bind} to reach the following.
      \[
        \wpre{\MLLdelete\,\langv{tl}\ \iindex}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, \vect{\val})}
      \]
      Which is the left-hand side of our IH.
    \item[Case Unmarked head:] We know that $\langv{hd} = \Some \loc$, $\vect{\val} = [\val'] + \vect{\val}''$ and $\loc \fmapsto (\val', \False, \langv{tl})$ with disjointed as IH the following.
      \[\All \iindex. \wpre{\MLLdelete\, \langv{tl}\; \iindex}{().\ \textlog{isMLL}\, \langv{tl}\; (\textlog{remove}\, \iindex\, \vect{\val}'')} \land \textlog{isMLL}\, \langv{tl}\, \vect{\val}''\]
      Thus, we need to prove that
      \[\wpre{\MLLdelete\, (\Some \loc)\; \iindex}{().\ \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, ([\val'] + \vect{\val}''))}\]
      We repeat the steps from the previous case, except for using $\loc \fmapsto (\val, \False, \langv{tl})$ with the \ruleref{wp-load} rule, until the second time we repeatedly use \ruleref{wp-pure} with \ruleref{wp-bind}. We instead use \ruleref{wp-bind} and \ruleref{wp-pure} once to reach the following statement:
      \[
        \wpre{\left(
          \begin{array}{l}
              \If \False = \False\ \&\&\ \iindex = 0 then \\
              \quad \loc \gets (\val', \True, \langv{tl}) \\
              \Else \If \False = \False then              \\
              \quad \MLLdelete\,\langv{tl}\ (\iindex - 1) \\
              \Else                                       \\
              \quad \MLLdelete\,\langv{tl}\ \iindex
            \end{array}
          \right)}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, \iindex\, ([\val'] + \vect{\val}''))}
      \]
      Here we do a case distinction on whether $\iindex = 0$, thus if we want to delete the current head of the MLL.
      \begin{description}
        \item[Case $i = 0$:] We repeatedly use \ruleref{wp-pure} with \ruleref{wp-bind} until we reach:
          \[
            \wpre{\loc \gets (\val, \True, \langv{tl})}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, 0\, ([\val'] + \vect{\val}''))}
          \]
          We then use \ruleref{wp-bind}, \ruleref{wp-store} with $\loc \fmapsto (\val, \True, \langv{tl})$, which we retained after the previous use of \ruleref{wp-load}, and \ruleref{wand-IE}. We now get that $\loc \fmapsto (\val', \False, \langv{tl})$, and we need to prove:
          \[
            \wpre{()}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, 0\, ([\val'] + \vect{\val}''))}
          \]
          We use \ruleref{wp-value} to reach:
          \[
            \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, 0\, ([\val'] + \vect{\val}''))
          \]
          This now follows from the fact that $(\textlog{remove}\, 0\, ([\val'] + \vect{\val}'')) = \vect{\val}''$ together with the third branch of the definition of $\textlog{isMLL}$, $\loc \fmapsto (\val', \False, \langv{tl})$ and the IH.
        \item[Case $i > 0$] We repeatedly use \ruleref{wp-pure} with \ruleref{wp-bind} until we reach:
          \[
            \wpre{\MLLdelete\,\langv{tl}\ (\iindex - 1)}{\Ret(). \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, (\iindex - 1)\, ([\val'] + \vect{\val}''))}
          \]
          We use \ruleref{wp-mono} with as assumption our the left-hand side of the IH, since it is not persistent we now lose the IH, but we don't need it any more. We now need to prove the following:
          \[\textlog{isMLL}\, \langv{tl}\; (\textlog{remove}\, \iindex\, \vect{\val}'') \proves \textlog{isMLL}\, (\Some \loc)\; (\textlog{remove}\, (\iindex - 1)\, ([\val'] + \vect{\val}''))\]
          This follows from the fact that $(\textlog{remove}\, (\iindex - 1)\, ([\val'] + \vect{\val}'')) = [\val'] + (\textlog{remove}\, \iindex\, \vect{\val}'')$ together with the third branch of the definition of $\textlog{isMLL}$ and $\loc \fmapsto (\val, \False, \langv{tl})$, which we retained from \ruleref{wp-load}.
      \end{description}
  \end{description}

\end{proof}

\end{document}