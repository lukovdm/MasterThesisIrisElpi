\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Background on separation logic}

In this chapter we give a background on separation logic by specifying and proving the correctness of a program on marked linked lists (MLLs), as seen in \cref*{ch:introduction}.

We will specify and proof deletion of an index in a marked linked list step by step. Thus, we will proof that delete defined in \cref*{sec:proofmll}, conforms to the specification below.
\begin{align*}
  \hoare{\textlog{isMLL}\, \langv{hd}\, \langv{vs}}{\operatorname{delete}\, \langv{hd}\; \langv{i}}{\textlog{isMLL}\, \langv{hd}\; (\textlog{remove}\, \langv{i}\, \langv{vs})}
\end{align*}

We will start by looking at separation as we will use it in the rest of this thesis in \cref*{sec:seplogic}. Next we show how to use separation logic to create hoare triples in the form of weakest preconditions to give a specification of a program in \cref*{sec:hoare}. Then, we will focus on how to create predicates that represent recursive data structures using fixpoints in \cref*{sec:represpreds}. Lastly we will finish the specification of a program manipulating marked linked lists in \cref*{sec:proofmll}.

\section{Separation logic}
\label{sec:seplogic}
\begin{align*}
  \type \bnfdef{}        & \sigtype \mid 0 \mid 1 \mid \type \to \type                                                                                                      \\[0.4em]
  \term, \prop \bnfdef{} & \var \mid \FALSE \mid \TRUE \mid \term =_\type \term \mid \prop \land \prop \mid \prop \lor \prop \mid \prop * \prop \mid \prop \wand \prop \mid \\
                         & \Exists \var:\type. \prop \mid \All \var:\type. \prop \mid \always\prop \mid {\later\prop} \mid \hoare{\prop}{\term}{v.\; \prop}                 \\
\end{align*}
\begin{itemize}
  \item We want to be able to reason about memory, heaps
  \item Use a logic that has extra connectives for talking about memory
  \item Most important, points to, $\fmapsto$
  \item Picture of memory with $l\fmapsto x$ next to it
  \item $l\fmapsto x$ means there is only one location in memory, $l$ and it has value $x$
  \item $\land$ now no longer works
  \item introduce *
  \item Another picture with logic next to it
  \item Describe rules of *
\end{itemize}
\begin{mathpar}
  \begin{array}{rMcMl}
    \TRUE * \prop             & \provesIff & \prop                     \\
    \prop * \propB            & \proves    & \propB * \prop            \\
    (\prop * \propB) * \propC & \proves    & \prop * (\propB * \propC)
  \end{array}
  \and
  \infer[$*$-mono]
  {\prop_1 \proves \propB_1 \and
    \prop_2 \proves \propB_2}
  {\prop_1 * \prop_2 \proves \propB_1 * \propB_2}
\end{mathpar}
\begin{itemize}
  \item This does not include $\prop \proves \prop * \prop$
\end{itemize}

\section{Writing specifications of programs}
\label{sec:hoare}
\begin{itemize}
  \item We will write our programs in heaplang, \ldots
  \item Start by verifying simple program
\end{itemize}
\begin{coqcode}
Definition copy_singleton : val :=
  λ: "l", let: "x" := !"l" in
          SOME (Alloc "x").
\end{coqcode}
\begin{itemize}
  \item We now want to specify what happens to the memory when the program executes
  \item Use hoare triples
\end{itemize}
\begin{coqcode}
Lemma copy_singleton_spec (x : val) (l : loc) :
  {{{ l ↦ (x, NONE) }}}
    copy_singleton #l
  {{{ v, RET v; v ↦ (x, NONE) ∗ l ↦ (x, NONE) }}}.
\end{coqcode}
\begin{itemize}
  \item Start with a description of the memory before copy singleton, precondition
  \item program to execute,
  \item \coqi{#l} transforms a location into a value in heaplang
  \item describe post condition
\end{itemize}

\section{Representation predicates}
\label{sec:represpreds}
\begin{itemize}
  \item Describe more parts of the logic, like persistent, later and magic wand
\end{itemize}

\section{Proof of delete in MLL}
\begin{align*}
  \RecV {delete}(\langv{l}, \langv{i}\,)=\  & \Match \langv{l}\, with                                                                           \\
                                            & \quad \None => \None |                                                                            \\
                                            & \quad \Some \langv{hd} =>                                                                         \\
                                            & \quad\quad \Let (\lvar, \langv{mark}, \langv{tl}) = \deref \langv{hd} in                          \\
                                            & \quad\quad \If \langv{mark} = \False \land \langv{i} = 0 then                                     \\
                                            & \quad\quad\quad \langv{hd} \gets (\lvar, \True, \langv{tl})                                       \\
                                            & \quad\quad \Else \If \langv{mark} = \False then                                                   \\
                                            & \quad\quad\quad \langv{hd} <- (\lvar, \False, \operatorname{delete}\,\langv{tl}\ (\langv{i} - 1)) \\
                                            & \quad\quad \Else                                                                                  \\
                                            & \quad\quad\quad \langv{hd} <- (\lvar, \True, \operatorname{delete}\,\langv{tl}\ (\langv{i}))      \\
                                            & end
\end{align*}
\label{sec:proofmll}

\end{document}