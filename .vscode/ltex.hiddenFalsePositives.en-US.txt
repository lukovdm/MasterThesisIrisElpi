{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe syntax we parse is <intropatternlist> ::= \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q <intropattern> <intropatternlist>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<intropattern> ::= <ident> `_' | `?'\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q| `#' | `*' | `**' | `/=' | `//' | `!%' `!>' | `->' | `<-' `[' <intropatternlist> `]' `(' <intropatternconjlist> `)' `%' <ident> `#' <intropattern> % Wait this one is weird `-#' <intropattern> `>' <intropattern>\\E$"}
{"rule":"ARROWS","sentence":"^\\Q| `#' | `*' | `**' | `/=' | `//' | `!%' `!>' | `->' | `<-' `[' <intropatternlist> `]' `(' <intropatternconjlist> `)' `%' <ident> `#' <intropattern> % Wait this one is weird `-#' <intropattern> `>' <intropattern>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<intropatternlist> ::= \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q <intropattern> `|' <intropatternlist> <intropattern> <intropatternlist>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<intropatternconjlist> ::= \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q <intropattern> ` ' <intropatternconjlist> With the caveat that a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has to have at least length 2.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q<intropatternconjlist> ::= \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q <intropattern> ` ' <intropatternconjlist> With the caveat that a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has to have at least length 2.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QOur subset is shown here <intropattern> ::= `*' `**' <simpleintropattern>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<simpleintropattern> ::= <namingintropattern> `' <orandintropattern> <equalityintropattern>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<namingintropattern> ::= <ident> `?'\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<orandintropattern> ::= `[' ( <intropattern>\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q )\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q|\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q `]' `(' <intropattern>\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q&\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q `)'\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q`?'<ident>\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q<equalityintropattern> ::= `->' `<-' `[=' <intropattern>\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q `]' …\\E$"}
{"rule":"ARROWS","sentence":"^\\Q<equalityintropattern> ::= `->' `<-' `[=' <intropattern>\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q `]' …\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QSealed goals allow us to program our tactics in separate steps, where each step is an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThese are cases like `//', `/=' and `%a'.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\Qis a tactics language for separation logic \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Is this the correct paper?.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qimplements \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qprolog and adds constraint handling rules to it.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\Qconsists of a separation logic \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and a tactics language for separation logic \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\Qis a separation logic \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and a tactics language for separation logic \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QTo be able to reason about this logic in coq a tactics language has been added called the Iris Proof Mode (IPM) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ON_IN_THE_MIDDLE","sentence":"^\\QThis introduces a variable without needing a name first two steps create the name of the variable Next we use a function as the proof term We extract the (term -> term) proof variable and the type Add the new variable to the context with the name Get the type of the new hole Call the continuation function on the hole in the context\\E$"}
{"rule":"ON_IN_THE_MIDDLE","sentence":"^\\QWhen introducing a forall we need to add the variable to our context Next steps in the proof thus need the new value in the context We have to use continuation passing style This introduces a variable without needing a name first two steps create the name of the variable Next we use a function as the proof term We extract the (term -> term) proof variable and the type Add the new variable to the context with the name Get the type of the new hole Call the continuation function on the hole in the context\\E$"}
