type sep_split list term -> open-tactic.
sep_split HS G GL :- coq.ltac.call "helper_eiSplit" [trm {list->listterm HS}] G GL.

type tc_solve open-tactic.
tc_solve G GL :- coq.ltac.call "tc_solve" [] G GL.

type pm_reduce open-tactic.
pm_reduce G GL :- coq.ltac.call "pm_reduce" [] G GL.

type split open-tactic.
split G GL :- coq.ltac.call "split" [] G GL.

solve (goal _Ctx _Trigger _Type _Proof [str HSS] as G) GL :-
        rex.split " " HSS HS,
        std.map HS string->stringterm HTS,
        std.map HTS (x\ r\ r = {{ INamed lp:x }}) HI,
        sep_split HI G GL0,
        std.nth 0 GL0 G1,
        coq.ltac.open tc_solve G1 GL1,
        std.nth 0 GL0 G2,
        coq.ltac.open pm_reduce G2 GL2,
        % std.nth 0 GL2 G3,
        % coq.ltac.open split G3 GL3,
        % Find out why it shelves
        std.append GL1 GL2 GL.